<title>PERL -- I/O Operations</title>
<H3>I/O Operations</H3>

<dl compact>
<p><dt><A NAME=binmode>binmode</A>(FILEHANDLE)<dt><A NAME=binmode FILEHANDLE>binmode FILEHANDLE</A><dd>
Arranges for the file to be read in "binary" mode in operating systems
that distinguish between binary and text files.
Files that are not read in binary mode have CR LF sequences translated
to LF on input and LF translated to CR LF on output.
Binmode has no effect under Unix.
If FILEHANDLE is an expression, the value is taken as the name of
the filehandle.

<p><dt><A NAME=close>close</A>(FILEHANDLE)<dt><A NAME=close FILEHANDLE>close FILEHANDLE</A><dd>
Closes the file or pipe associated with the file handle.
You don't have to close FILEHANDLE if you are immediately going to
do another open on it, since open will close it for you.
(See
<I>open</I>.)
However, an explicit close on an input file resets the line counter ($.), while
the implicit close done by
<I>open</I>
does not.
Also, closing a pipe will wait for the process executing on the pipe to complete,
in case you want to look at the output of the pipe afterwards.
Closing a pipe explicitly also puts the status value of the command into <A HREF=pl-predef.html#$?>$?</A>.
Example:
<pre>
	open(OUTPUT, '|sort &gt;foo');	# pipe to sort
	...	# print stuff to output
	close OUTPUT;		# wait for sort to finish
	open(INPUT, 'foo');	# get sort's results
</pre>
FILEHANDLE may be an expression whose value gives the real filehandle name.
<p><dt><A NAME=dbmclose>dbmclose</A>(ASSOC_ARRAY)<dt><A NAME=dbmclose ASSOC_ARRAY>dbmclose ASSOC_ARRAY</A><dd>
Breaks the binding between a dbm file and an associative array.
The values remaining in the associative array are meaningless unless
you happen to want to know what was in the cache for the dbm file.
This function is only useful if you have ndbm.
<p><dt><A NAME=dbmopen>dbmopen</A>(ASSOC,DBNAME,MODE)<dd>This binds a dbm or ndbm file to an associative array.
ASSOC is the name of the associative array.
(Unlike normal open, the first argument is NOT a filehandle, even though
it looks like one).
DBNAME is the name of the database (without the .dir or .pag extension).
If the database does not exist, it is created with protection specified
by MODE (as modified by the <A HREF=pl-exp-sys.html#umask>umask</A>).
If your system only supports the older dbm functions, you may perform only one
dbmopen in your program.
If your system has neither dbm nor ndbm, calling dbmopen produces a fatal
error.
<p>
Values assigned to the associative array prior to the dbmopen are lost.
A certain number of values from the dbm file are cached in memory.
By default this number is 64, but you can increase it by preallocating
that number of garbage entries in the associative array before the dbmopen.
You can flush the cache if necessary with the <A HREF=pl-exp-misc.html#reset>reset</A> command.
<p>
If you don't have write access to the dbm file, you can only read
associative array variables, not set them.
If you want to test whether you can write, either use file tests or
try setting a dummy array entry inside an eval, which will trap the error.
<p>
Note that functions such as <A HREF=pl-exp-arr.html#keys>keys</A>() and <A HREF=pl-exp-arr.html#values>values</A>() may return huge array <A HREF=pl-exp-arr.html#values>values</A>
when used on large dbm files.
You may prefer to use the <A HREF=pl-exp-arr.html#each>each</A>() function to iterate over large dbm files.
Example:
<pre>
	# print out history file offsets
	dbmopen(HIST,'/usr/lib/news/history',0666);
	<A HREF=pl-compound.html#while>while</A> (($key,$val) = <A HREF=pl-exp-arr.html#each>each</A> %HIST) {
		print $key, ' = ', <A HREF=pl-exp-conv.html#unpack>unpack</A>('L',$val), "\n";
	}
	dbmclose(HIST);
</pre>
<p><dt><A NAME=eof>eof</A>(FILEHANDLE)<dt>eof()
<dt><A NAME=eof>eof</A><dd>Returns 1 if the next read on FILEHANDLE will return end of file, or if
FILEHANDLE is not open.
FILEHANDLE may be an expression whose value gives the real filehandle name.
(Note that this function actually reads a character and then ungetc's it,
so it is not very useful in an interactive context.)
An eof without an argument returns the eof status for the last file read.
Empty parentheses () may be used to indicate the pseudo file formed of the
files listed on the command line, i.e. eof() is reasonable to use inside
a <A HREF=pl-compound.html#while>while</A> (&lt;&gt;) loop to detect the end of only the last file.
Use eof(ARGV) or eof without the parentheses to test EACH file in a <A HREF=pl-compound.html#while>while</A> (&lt;&gt;) loop.
Examples:
<pre>
	# insert dashes just before last line of last file
	<A HREF=pl-compound.html#while>while</A> (&lt;&gt;) {
		<A HREF=pl-compound.html#if>if</A> (eof()) {
			print "--------------\n";
		}
		print;
	}

	# reset line numbering on each input file
	<A HREF=pl-compound.html#while>while</A> (&lt;&gt;) {
		print "$.\t$_";
		<A HREF=pl-compound.html#if>if</A> (eof) {	# Not eof().
			close(ARGV);
		}
	}
</pre>
<p><dt><A NAME=fcntl>fcntl</A>(FILEHANDLE,FUNCTION,SCALAR)<dd>Implements the fcntl(2) function.
You'll probably have to say
<pre>
	<A HREF=pl-exp-misc.html#require>require</A> "fcntl.ph";	# probably /usr/local/lib/perl/fcntl.ph
</pre>
first to get the correct function definitions.
If fcntl.ph doesn't exist or doesn't have the correct definitions
you'll have to roll
your own, based on your C header files such as &lt;sys/fcntl.h&gt;.
(There is a perl script called h2ph that comes with the perl kit
which may help you in this.)
Argument processing and value return works just like ioctl below.
Note that fcntl will produce a fatal error if used on a machine that doesn't implement
fcntl(2).
<p><dt><A NAME=fileno>fileno</A>(FILEHANDLE)<dt><A NAME=fileno FILEHANDLE>fileno FILEHANDLE</A><dd>
Returns the file descriptor for a filehandle.
Useful for constructing bitmaps for select().
If FILEHANDLE is an expression, the value is taken as the name of
the filehandle.
<p><dt><A NAME=flock>flock</A>(FILEHANDLE,OPERATION)<dd>Calls flock(2) on FILEHANDLE.
See manual page for flock(2) for definition of OPERATION.
Returns true for success, false on failure.
Will produce a fatal error if used on a machine that doesn't implement
flock(2).
Here's a mailbox appender for BSD systems.
<pre>
	$LOCK_SH = 1;
	$LOCK_EX = 2;
	$LOCK_NB = 4;
	$LOCK_UN = 8;

	sub lock {
	    flock(MBOX,$LOCK_EX);
	    # and, in case someone appended
	    # while we were waiting...
	    seek(MBOX, 0, 2);
	}

	sub unlock {
	    flock(MBOX,$LOCK_UN);
	}

	open(MBOX, "&gt;&gt;/usr/spool/mail/$ENV{'USER'}")
		|| <A HREF=pl-exp-sys.html#die>die</A> "Can't open mailbox: <A HREF=pl-predef.html#$!>$!</A>";

	<A HREF=pl-exp-flow.html#do>do</A> lock();
	print MBOX $msg,"\n\n";
	<A HREF=pl-exp-flow.html#do>do</A> unlock();
</pre>
<p><dt><A NAME=getc>getc</A>(FILEHANDLE)<dt>getc FILEHANDLE
<dt><A NAME=getc>getc</A><dd>Returns the next character from the input file attached to FILEHANDLE, or
a null string at EOF.
If FILEHANDLE is omitted, reads from STDIN.
<p><dt><A NAME=ioctl>ioctl</A>(FILEHANDLE,FUNCTION,SCALAR)<dd>Implements the ioctl(2) function.
You'll probably have to say
<pre>
	<A HREF=pl-exp-misc.html#require>require</A> "ioctl.ph";	# probably /usr/local/lib/perl/ioctl.ph
</pre>
first to get the correct function definitions.
If ioctl.ph doesn't exist or doesn't have the correct definitions
you'll have to roll
your own, based on your C header files such as &lt;sys/ioctl.h&gt;.
(There is a perl script called h2ph that comes with the perl kit
which may help you in this.)
SCALAR will be read and/or written depending on the FUNCTION--a pointer
to the string value of SCALAR will be passed as the third argument of
the actual ioctl call.
(If SCALAR has no string value but does have a numeric value, that value
will be passed rather than a pointer to the string value.
To guarantee this to be true, add a 0 to the scalar before using it.)
The <A HREF=pl-exp-conv.html#pack>pack</A>() and <A HREF=pl-exp-conv.html#unpack>unpack</A>() functions are useful for manipulating the values
of structures used by ioctl().
The following example sets the erase character to DEL.
<pre>
	<A HREF=pl-exp-misc.html#require>require</A> 'ioctl.ph';
	$sgttyb_t = "ccccs";		# 4 chars and a short
	<A HREF=pl-compound.html#if>if</A> (ioctl(STDIN,$TIOCGETP,$sgttyb)) {
		@ary = <A HREF=pl-exp-conv.html#unpack>unpack</A>($sgttyb_t,$sgttyb);
		$ary[2] = 127;
		$sgttyb = <A HREF=pl-exp-conv.html#pack>pack</A>($sgttyb_t,@ary);
		ioctl(STDIN,$TIOCSETP,$sgttyb)
			|| <A HREF=pl-exp-sys.html#die>die</A> "Can't ioctl: <A HREF=pl-predef.html#$!>$!</A>";
	}
</pre>
The return value of ioctl (and fcntl) is as follows:
<pre>
	if OS returns:\h'|3i'perl returns:
	  -1\h'|3i'  undefined value
	  0\h'|3i'  string "0 but true"
	  anything else\h'|3i'  that number
</pre>
Thus perl returns true on success and false on failure, yet you can still
easily determine the actual value returned by the operating system:
<pre>
	($retval = ioctl(...)) || ($retval = -1);
	printf "System returned %d\n", $retval;</pre>
<p><dt><A NAME=open>open</A>(FILEHANDLE,EXPR)<dt>open(FILEHANDLE)
<dt><A NAME=open>open</A> FILEHANDLE<dd>Opens the file whose filename is given by EXPR, and associates it with
FILEHANDLE.
If FILEHANDLE is an expression, its value is used as the name of the
real filehandle wanted.
If EXPR is omitted, the scalar variable of the same name as the FILEHANDLE
contains the filename.
If the filename begins with "&lt;" or nothing, the file is opened for
input.
If the filename begins with "&gt;", the file is opened for output.
If the filename begins with "&gt;&gt;", the file is opened for appending.
(You can put a '+' in front of the '&gt;' or '&lt;' to indicate that you
want both read and write access to the file.)
If the filename begins with "|", the filename is interpreted
as a command to which output is to be piped, and if the filename ends
with a "|", the filename is interpreted as command which pipes
input to us.
(You may not have a command that pipes both in and out.)
Opening '-' opens
<I>STDIN</I>
and opening '&gt;-' opens
<I>STDOUT</I>.
Open returns non-zero upon success, the undefined value otherwise.
If the open involved a pipe, the return value happens to be the pid
of the subprocess.
Examples:
<pre>    
	$article = 100;
	open article || <A HREF=pl-exp-sys.html#die>die</A> "Can't find article $article: $!\n";
	<A HREF=pl-compound.html#while>while</A> (&lt;article&gt;) {...

	open(LOG, '&gt;&gt;/usr/spool/news/twitlog');
					# (log is reserved)

	open(article, "caesar &lt;$article |");
					# decrypt article

	open(extract, "|sort &gt;/tmp/Tmp$$");
					# <A HREF=pl-predef.html#$$>$$</A> is our process#

	# process argument list of files along with any includes

	<A HREF=pl-compound.html#foreach>foreach</A> $file (@ARGV) {
		<A HREF=pl-exp-flow.html#do>do</A> process($file, 'fh00');	# no pun intended
	}

	sub process {
		<A HREF=pl-exp-misc.html#local>local</A>($filename, $input) = @_;
		$input++;		# this is a string increment
		unless (open($input, $filename)) {
			print STDERR "Can't open $filename: $!\n";
			return;
		}
		<A HREF=pl-compound.html#while>while</A> (&lt;$input&gt;) {		# note use of indirection
			<A HREF=pl-compound.html#if>if</A> (/^#include "(.*)"/) {
				<A HREF=pl-exp-flow.html#do>do</A> process($1, $input);
				next;
			}
			...		# whatever
		}
	}
</pre>
You may also, in the Bourne shell tradition, specify an EXPR beginning
with "&gt;&amp;", in which case the rest of the string
is interpreted as the name of a filehandle
(or file descriptor, if numeric) which is to be duped and opened.
You may use &amp; after &gt;, &gt;&gt;, &lt;, +&gt;, +&gt;&gt; and +&lt;.
The mode you specify should match the mode of the original filehandle.
Here is a script that saves, redirects, and restores
<I>STDOUT</I>
and
<I>STDERR</I>:
<pre>
	#!/usr/bin/perl
	open(SAVEOUT, "&gt;&amp;STDOUT");
	open(SAVEERR, "&gt;&amp;STDERR");

	open(STDOUT, "&gt;foo.out") || <A HREF=pl-exp-sys.html#die>die</A> "Can't redirect stdout";
	open(STDERR, "&gt;&amp;STDOUT") || <A HREF=pl-exp-sys.html#die>die</A> "Can't dup stdout";

	select(STDERR); <A HREF=pl-predef.html#$|>$|</A> = 1;		# make unbuffered
	select(STDOUT); <A HREF=pl-predef.html#$|>$|</A> = 1;		# make unbuffered

	print STDOUT "stdout 1\n";	# this works for
	print STDERR "stderr 1\n"; 	# subprocesses too

	close(STDOUT);
	close(STDERR);

	open(STDOUT, "&gt;&amp;SAVEOUT");
	open(STDERR, "&gt;&amp;SAVEERR");

	print STDOUT "stdout 2\n";
	print STDERR "stderr 2\n";
</pre>
If you open a pipe on the command "-", i.e. either "|-" or "-|",
then there is an implicit fork done, and the return value of open
is the pid of the child within the parent process, and 0 within the child
process.
(Use <A HREF=pl-exp-misc.html#defined>defined</A>($pid) to determine if the open was successful.)
The filehandle behaves normally for the parent, but i/o to that
filehandle is piped from/to the
<I>STDOUT</I>/ STDIN
of the child process.
In the child process the filehandle isn't opened--i/o happens from/to
the new
<I>STDOUT</I>
or
<I>STDIN</I>.
Typically this is used like the normal piped open when you want to exercise
more control over just how the pipe command gets executed, such as when
you are running setuid, and don't want to have to scan shell commands
for metacharacters.
The following pairs are more or less equivalent:
<pre>
	open(FOO, "|tr '[a-z]' '[A-Z]'");
	open(FOO, "|-") || <A HREF=pl-exp-sys.html#exec>exec</A> 'tr', '[a-z]', '[A-Z]';

	open(FOO, "cat -n '$file'|");
	open(FOO, "-|") || <A HREF=pl-exp-sys.html#exec>exec</A> 'cat', '-n', $file;
</pre>
Explicitly closing any piped filehandle causes the parent process to wait for the
child to finish, and returns the status value in <A HREF=pl-predef.html#$?>$?</A>.
Note: on any operation which may do a fork,
unflushed buffers remain unflushed in both
processes, which means you may need to set <A HREF=pl-predef.html#$|>$|</A> to
avoid duplicate output.
<p>
The filename that is passed to open will have leading and trailing
whitespace deleted.
In order to open a file with arbitrary weird characters in it, it's necessary
to protect any leading and trailing whitespace thusly:
<pre>
        $file <A HREF=pl-exp-op.html#=~>=~</A> s#^(\s)#./$1#;
        open(FOO, "&lt; $file\0");
</pre>
<p><dt><A NAME=pipe>pipe</A>(READHANDLE,WRITEHANDLE)<dd>Opens a pair of connected pipes like the corresponding system call.
Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.
In addition, note that perl's pipes use stdio buffering, so you may need
to set <A HREF=pl-predef.html#$|>$|</A> to flush your WRITEHANDLE after each command, depending on
the application.
[Requires version 3.0 patchlevel 9.]
<p><dt><A NAME=print>print</A>(FILEHANDLE LIST)<dt>print(LIST)
<dt><A NAME=print>print</A> FILEHANDLE LIST<dt>print LIST
<dt><A NAME=print>print</A><dd>Prints a string or a comma-separated list of strings.
Returns non-zero if successful.
FILEHANDLE may be a scalar variable name, in which case the variable contains
the name of the filehandle, thus introducing one level of indirection.
(NOTE: If FILEHANDLE is a variable and the next token is a term, it may be
misinterpreted as an operator unless you interpose a + or put parens around
the arguments.)
If FILEHANDLE is omitted, prints by default to standard output (or to the
last selected output channel--see select()).
If LIST is also omitted, prints <A HREF=pl-predef.html#$_>$_</A> to
<I>STDOUT</I>.
To set the default output channel to something other than
<I>STDOUT</I>
use the select operation.
Note that, because print takes a LIST, anything in the LIST is evaluated
in an array context, and any subroutine that you call will have one or more
of its expressions evaluated in an array context.
Also be careful not to follow the print keyword with a left parenthesis
unless you want the corresponding right parenthesis to terminate the
arguments to the print--interpose a + or put parens around all the arguments.
<p><dt><A NAME=printf>printf</A>(FILEHANDLE LIST)<dt>printf(LIST)
<dt><A NAME=printf>printf</A> FILEHANDLE LIST<dt><A NAME=printf LIST>printf LIST</A><dd>
Equivalent to a "print FILEHANDLE sprintf(LIST)".
<p><dt><A NAME=read>read</A>(FILEHANDLE,SCALAR,LENGTH,OFFSET)<dt><A NAME=read(FILEHANDLE,SCALAR,LENGTH)>read(FILEHANDLE,SCALAR,LENGTH)</A><dd>
Attempts to read LENGTH bytes of data into variable SCALAR from the specified
FILEHANDLE.
Returns the number of bytes actually read, or undef if there was an error.
SCALAR will be grown or shrunk to the length actually read.
An OFFSET may be specified to place the read data at some other place
than the beginning of the string.
This call is actually implemented in terms of stdio's fread call.  To get
a true read system call, see sysread.
<p><dt><A NAME=seek>seek</A>(FILEHANDLE,POSITION,WHENCE)<dd>Randomly positions the file pointer for FILEHANDLE, just like the fseek()
call of stdio.
FILEHANDLE may be an expression whose value gives the name of the filehandle.
Returns 1 upon success, 0 otherwise.
<p><dt><A NAME=select>select</A>(FILEHANDLE)<dt><A NAME=select>select</A><dd>
Returns the currently selected filehandle.
Sets the current default filehandle for output, if FILEHANDLE is supplied.
This has two effects: first, a
<I>write</I>
or a
<I>print</I>
without a filehandle will default to this FILEHANDLE.
Second, references to variables related to output will refer to this output
channel.
For example, if you have to set the top of form format for more than
one output channel, you might do the following:
<pre>
	select(REPORT1);
	<A HREF=pl-predef.html#$^>$^</A> = 'report1_top';
	select(REPORT2);
	<A HREF=pl-predef.html#$^>$^</A> = 'report2_top';
</pre>
FILEHANDLE may be an expression whose value gives the name of the actual filehandle.
Thus:
<pre>
	$oldfh = select(STDERR); <A HREF=pl-predef.html#$|>$|</A> = 1; select($oldfh);
</pre>
<p><dt><A NAME=sprintf>sprintf</A>(FORMAT,LIST)<dd>Returns a string formatted by the usual printf conventions.
The * character is not supported.
<p><dt><A NAME=sysread>sysread</A>(FILEHANDLE,SCALAR,LENGTH,OFFSET)<dt><A NAME=sysread(FILEHANDLE,SCALAR,LENGTH)>sysread(FILEHANDLE,SCALAR,LENGTH)</A><dd>
Attempts to read LENGTH bytes of data into variable SCALAR from the specified
FILEHANDLE, using the system call read(2).
It bypasses stdio, so mixing this with other kinds of reads may cause
confusion.
Returns the number of bytes actually read, or undef if there was an error.
SCALAR will be grown or shrunk to the length actually read.
An OFFSET may be specified to place the read data at some other place
than the beginning of the string.
<p><dt><A NAME=syswrite>syswrite</A>(FILEHANDLE,SCALAR,LENGTH,OFFSET)<dt><A NAME=syswrite(FILEHANDLE,SCALAR,LENGTH)>syswrite(FILEHANDLE,SCALAR,LENGTH)</A><dd>
Attempts to write LENGTH bytes of data from variable SCALAR to the specified
FILEHANDLE, using the system call write(2).
It bypasses stdio, so mixing this with prints may cause
confusion.
Returns the number of bytes actually written, or undef if there was an error.
An OFFSET may be specified to place the read data at some other place
than the beginning of the string.
<p><dt><A NAME=tell>tell</A>(FILEHANDLE)<dt>tell FILEHANDLE
<dt><A NAME=tell>tell</A><dd>Returns the current file position for FILEHANDLE.
FILEHANDLE may be an expression whose value gives the name of the actual
filehandle.
If FILEHANDLE is omitted, assumes the file last read.
<p><dt><A NAME=write>write</A>(FILEHANDLE)<dt>write(EXPR)
<dt><A NAME=write>write</A><dd>Writes a formatted record (possibly multi-line) to the specified file,
using the format associated with that file.
By default the format for a file is the one having the same name is the
filehandle, but the format for the current output channel (see
<I>select</I>)
may be set explicitly
by assigning the name of the format to the <A HREF=pl-predef.html#$~>$~</A> variable.
<p>
Top of form processing is handled automatically:
if there is insufficient room on the current page for the formatted 
record, the page is advanced by writing a form feed,
a special top-of-page format is used
to format the new page header, and then the record is written.
By default the top-of-page format is the name of the filehandle with
"_TOP" appended, but it may be dynamicallly set to the
format of your choice by assigning the name to the <A HREF=pl-predef.html#$^>$^</A> variable while
the filehandle is selected.
The number of lines remaining on the current page is in variable $-, which
can be set to 0 to force a new page.
<p>
If FILEHANDLE is unspecified, output goes to the current default output channel,
which starts out as
<I>STDOUT</I>
but may be changed by the
<I>select</I>
operator.
If the FILEHANDLE is an EXPR, then the expression is evaluated and the
resulting string is used to look up the name of the FILEHANDLE at run time.
For more on formats, see the section on formats later on.
<p>
Note that write is NOT the opposite of read.
</dl>
