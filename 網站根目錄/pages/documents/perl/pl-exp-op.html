<title>PERL -- Operators</title>
<h3>Operators</H3>
Since
<I>perl</I>
expressions work almost exactly like C expressions, only the differences
will be mentioned here.
<P>
Here's what
<I>perl</I>
has that C doesn't:
<dl compact>
<p><dt><A NAME=**>**</A><dd>The exponentiation operator.
<p><dt><A NAME=**=>**=</A><dd>The exponentiation assignment operator.
<p><dt><A NAME=()>()</A><dd>The null list, used to initialize an array to null.
<p><dt>.<dd>Concatenation of two strings.
<p><dt><A NAME=.=>.=</A><dd>The concatenation assignment operator.
<p><dt><A NAME=eq>eq</A><dd>String equality (== is numeric equality).
For a mnemonic just think of "eq" as a string.
(If you are used to the
<I>awk</I>
behavior of using == for either string or numeric equality
based on the current form of the comparands, beware!
You must be explicit here.)
<p><dt><A NAME=ne>ne</A><dd>String inequality (!= is numeric inequality).
<p><dt><A NAME=lt>lt</A><dd>String less than.
<p><dt><A NAME=gt>gt</A><dd>String greater than.
<p><dt><A NAME=le>le</A><dd>String less than or equal.
<p><dt><A NAME=ge>ge</A><dd>String greater than or equal.
<p><dt><A NAME=cmp>cmp</A><dd>String comparison, returning -1, 0, or 1.
<p><dt><A NAME=lt=gt>&lt;=&gt;</A><dd>Numeric comparison, returning -1, 0, or 1.
<p><dt><A NAME==~>=~</A><dd>Certain operations search or modify the string "<A HREF=pl-predef.html#$_>$_</A>" by default.
This operator makes that kind of operation work on some other string.
The right argument is a search pattern, substitution, or translation.
The left argument is what is supposed to be searched, substituted, or
translated instead of the default "<A HREF=pl-predef.html#$_>$_</A>".
The return value indicates the success of the operation.
(If the right argument is an expression other than a search pattern,
substitution, or translation, it is interpreted as a search pattern
at run time.
This is less efficient than an explicit search, since the pattern must
be compiled every time the expression is evaluated.)
The precedence of this operator is lower than unary minus and autoincrement/decrement, but higher than everything else.
<p><dt><A NAME=!~>!~</A><dd>Just like =~ except the return value is negated.
<p><dt><A NAME=x>x</A><dd>The repetition operator.
Returns a string consisting of the left operand repeated the
number of times specified by the right operand.
In an array context, if the left operand is a list in parens, it repeats
the list.
<pre>
	<A HREF=pl-exp-io.html#print>print</A> '-' x 80;		# <A HREF=pl-exp-io.html#print>print</A> row of dashes
	<A HREF=pl-exp-io.html#print>print</A> '-' x80;		# illegal, x80 is identifier

	<A HREF=pl-exp-io.html#print>print</A> "\t" x ($tab/8), ' ' x ($tab%8);	# tab over

	@ones = (1) x 80;		# an array of 80 1's
	@ones = (5) x @ones;		# set all elements to 5
</pre>
<p><dt><A NAME=x>x</A>=<dd>The repetition assignment operator.
Only works on scalars.
<p><dt><A NAME=..>..</A><dd>The range operator, which is really two different operators depending
on the context.
In an array context, returns an array of values counting (by ones)
from the left value to the right value.
This is useful for writing "<A HREF=pl-compound.html#for>for</A> (1..10)" loops and for doing
slice operations on arrays.
<p>
In a scalar context, .. returns a boolean value.
The operator is bistable, like a flip-flop, and
emulates the line-range (comma) operator of sed, awk, and various editors.
Each .. operator maintains its own boolean state.
It is false as long as its left operand is false.
Once the left operand is true, the range operator stays true
until the right operand is true,
AFTER which the range operator becomes false again.
(It doesn't become false till the next time the range operator is evaluated.
It can test the right operand and become false on the
same evaluation it became true (as in awk), but it still returns true once.
If you don't want it to test the right operand till the next
evaluation (as in sed), use three dots (...) instead of two.)
The right operand is not evaluated while the operator is in the "false" state,
and the left operand is not evaluated while the operator is in the "true" state.
The precedence is a little lower than || and &amp;&amp;.
The value returned is either the null string for false, or a sequence number
(beginning with 1) for true.
The sequence number is reset for each range encountered.
The final sequence number in a range has the string 'E0' appended to it, which
doesn't affect its numeric value, but gives you something to search for if you
want to exclude the endpoint.
You can exclude the beginning point by waiting for the sequence number to be
greater than 1.
If either operand of scalar .. is static, that operand is implicitly compared
to the $. variable, the current line number.
<p>
Examples:
<pre>
As a scalar operator:
    <A HREF=pl-compound.html#if>if</A> (101 .. 200) { <A HREF=pl-exp-io.html#print>print</A>; }	# <A HREF=pl-exp-io.html#print>print</A> 2nd hundred lines

    <A HREF=pl-exp-flow.html#next>next</A> line <A HREF=pl-compound.html#if>if</A> (1 .. /^$/);	# skip header lines

    s/^/&gt; / <A HREF=pl-compound.html#if>if</A> (/^$/ .. <A HREF=pl-exp-io.html#eof>eof</A>());	# quote body

As an array operator:
    <A HREF=pl-compound.html#for>for</A> (101 .. 200) { <A HREF=pl-exp-io.html#print>print</A>; }	# <A HREF=pl-exp-io.html#print>print</A> <A HREF=pl-predef.html#$_>$_</A> 100 times

    @foo = @foo[$[ .. $#foo];	# an expensive no-op
    @foo = @foo[$#foo-4 .. $#foo];	# slice last 5 items
</pre>
<p><dt><A NAME=-x>-x</A><dd>A file test.
This unary operator takes one argument, either a filename or a filehandle,
and tests the associated file to see if something is true about it.
If the argument is omitted, tests $_, except for -t, which tests
<I>STDIN</I>.
It returns 1 for true and '' for false, or the undefined value if the
file doesn't exist.
Precedence is higher than logical and relational operators, but lower than
arithmetic operators.
The operator may be any of:
<pre>	-r	File is readable by effective uid/gid.
	-w	File is writable by effective uid/gid.
	-x	File is executable by effective uid/gid.
	-o	File is owned by effective uid.
	-R	File is readable by real uid/gid.
	-W	File is writable by real uid/gid.
	-X	File is executable by real uid/gid.
	-O	File is owned by real uid.
	-e	File exists.
	-z	File has zero size.
	-s	File has non-zero size (returns size).
	-f	File is a plain file.
	-d	File is a directory.
	-l	File is a symbolic link.
	-p	File is a named pipe (FIFO).
	-S	File is a socket.
	-b	File is a block special file.
	-c	File is a character special file.
	-u	File has setuid bit set.
	-g	File has setgid bit set.
	-k	File has sticky bit set.
	-t	Filehandle is opened to a tty.
	-T	File is a text file.
	-B	File is a binary file (opposite of -T).
	-M	Age of file in days when script started.
	-A	Same for access time.
	-C	Same for inode change time.
</pre>
The interpretation of the file permission operators -r, -R, -w, -W, -x and -X
is based solely on the mode of the file and the uids and gids of the user.
There may be other reasons you can't actually read, write or execute the file.
Also note that, for the superuser, -r, -R, -w and -W always return 1, and 
-x and -X return 1 if any execute bit is set in the mode.
Scripts run by the superuser may thus need to do a <A HREF=pl-exp-file.html#stat>stat</A>() in order to determine
the actual mode of the file, or temporarily set the uid to something else.
<p>
Example:
<pre>	
	<A HREF=pl-compound.html#while>while</A> (&lt;&gt;) {
		chop;
		<A HREF=pl-exp-flow.html#next>next</A> unless -f $_;	# ignore specials
		...
	}
</pre>
Note that -s/a/b/ does not do a negated substitution.
Saying -exp($foo) still works as expected, however--only single letters
following a minus are interpreted as file tests.
<p>
The -T and -B switches work as follows.
The first block or so of the file is examined for odd characters such as
strange control codes or metacharacters.
If too many odd characters (&gt;10%) are found, it's a -B file, otherwise it's a -T file.
Also, any file containing null in the first block is considered a binary file.
If -T or -B is used on a filehandle, the current stdio buffer is examined
rather than the first block.
Both -T and -B return TRUE on a null file, or a file at EOF when testing
a filehandle.
<P>
If any of the file tests (or either <A HREF=pl-exp-file.html#stat>stat</A> operator) are given the special
filehandle consisting of a solitary underline, then the stat structure
of the previous file test (or <A HREF=pl-exp-file.html#stat>stat</A> operator) is used, saving a system
call.
(This doesn't work with -t, and you need to remember that <A HREF=pl-exp-file.html#lstat>lstat</A> and -l
will leave values in the stat structure for the symbolic link, not the
real file.)
<p>
Example:
<pre>
	<A HREF=pl-exp-io.html#print>print</A> "Can do.\n" <A HREF=pl-compound.html#if>if</A> -r $a || -w _ || -x _;

	<A HREF=pl-exp-file.html#stat>stat</A>($filename);
	<A HREF=pl-exp-io.html#print>print</A> "Readable\n" <A HREF=pl-compound.html#if>if</A> -r _;
	<A HREF=pl-exp-io.html#print>print</A> "Writable\n" <A HREF=pl-compound.html#if>if</A> -w _;
	<A HREF=pl-exp-io.html#print>print</A> "Executable\n" <A HREF=pl-compound.html#if>if</A> -x _;
	<A HREF=pl-exp-io.html#print>print</A> "Setuid\n" <A HREF=pl-compound.html#if>if</A> -u _;
	<A HREF=pl-exp-io.html#print>print</A> "Setgid\n" <A HREF=pl-compound.html#if>if</A> -g _;
	<A HREF=pl-exp-io.html#print>print</A> "Sticky\n" <A HREF=pl-compound.html#if>if</A> -k _;
	<A HREF=pl-exp-io.html#print>print</A> "Text\n" <A HREF=pl-compound.html#if>if</A> -T _;
	<A HREF=pl-exp-io.html#print>print</A> "Binary\n" <A HREF=pl-compound.html#if>if</A> -B _;
</pre>
</dl>
<P>
Here is what C has that
<I>perl</I>
doesn't:
<dl compact>
<p><dt><A NAME=unary>unary</A> &amp;<dd>Address-of operator.
<p><dt><A NAME=unary>unary</A> *<dd>Dereference-address operator.
<p><dt><A NAME=(TYPE)>(TYPE)</A><dd>Type casting operator.
</dl>
<P>
Like C,
<I>perl</I>
does a certain amount of expression evaluation at compile time, whenever
it determines that all of the arguments to an operator are static and have
no side effects.
In particular, string concatenation happens at compile time between literals that don't do variable substitution.
Backslash interpretation also happens at compile time.
You can say
<pre>
	'Now is the time for all' . "\n" .
	'good men to come to.'
</pre>
and this all reduces to one string internally.
<P>
The autoincrement operator has a little extra built-in magic to it.
If you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.
If, however, the variable has only been used in string contexts since it
was set, and has a value that is not null and matches the
pattern /^[a-zA-Z]*[0-9]*$/, the increment is done
as a string, preserving each character within its range, with carry:
<pre>
	<A HREF=pl-exp-io.html#print>print</A> ++($foo = '99');	# prints '100'
	<A HREF=pl-exp-io.html#print>print</A> ++($foo = 'a0');	# prints 'a1'
	<A HREF=pl-exp-io.html#print>print</A> ++($foo = 'Az');	# prints 'Ba'
	<A HREF=pl-exp-io.html#print>print</A> ++($foo = 'zz');	# prints 'aaa'
</pre>
The autodecrement is not magical.
<P>
The range operator (in an array context) makes use of the magical
autoincrement algorithm if the minimum and maximum are strings.
You can say

	@alphabet = ('A' .. 'Z');

to get all the letters of the alphabet, or

	$hexdigit = (0 .. 9, 'a' .. 'f')[$num &amp; 15];

to get a hexadecimal digit, or

	@z2 = ('01' .. '31');  <A HREF=pl-exp-io.html#print>print</A> @z2[$mday];

to get dates with leading zeros.
(If the final value specified is not in the sequence that the magical increment
would produce, the sequence goes until the next value would be longer than
the final value specified.)
<P>
The || and &amp;&amp; operators differ from C's in that, rather than returning 0 or 1,
they return the last value evaluated. 
Thus, a portable way to find out the home directory might be:
<pre>
	$home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
	    (getpwuid(<A HREF=pl-predef.html#$&lt;>$&lt;</A>))[7] || <A HREF=pl-exp-sys.html#die>die</A> "You're homeless!\n";
</pre>
<P>
Along with the literals and variables mentioned earlier,
the operations in the following section can serve as terms in an expression.
Some of these operations take a LIST as an argument.
Such a list can consist of any combination of scalar arguments or array values;
the array values will be included in the list as if each individual element were
interpolated at that point in the list, forming a longer single-dimensional
array value.
Elements of the LIST should be separated by commas.
If an operation is listed both with and without parentheses around its
arguments, it means you can either use it as a unary operator or
as a function call.
To use it as a function call, the next token on the same line must
be a left parenthesis.
(There may be intervening white space.)
Such a function then has highest precedence, as you would expect from
a function.
If any token other than a left parenthesis follows, then it is a
unary operator, with a precedence depending only on whether it is a LIST
operator or not.
LIST operators have lowest precedence.
All other unary operators have a precedence greater than relational operators
but less than arithmetic operators.
See the section on Precedence.
<P>
For operators that can be used in either a scalar or array context,
failure is generally indicated in a scalar context by returning
the undefined value, and in an array context by returning the null list.
Remember though that
<b>there is no general rule for converting a list into a scalar</b>.
Each operator decides which sort of scalar it would be most
appropriate to return.
Some operators return the length of the list
that would have been returned in an array context.
Some operators return the first value in the list.
Some operators return the last value in the list.
Some operators return a count of successful operations.
In general, they do what you want, unless you want consistency.
