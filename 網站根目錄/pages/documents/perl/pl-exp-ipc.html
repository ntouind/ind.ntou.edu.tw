<title>PERL -- IPC and Networking Operations</title>
<H3>IPC and Networking Operations</H3>

<dl compact>
<p><dt><A NAME=accept>accept</A>(NEWSOCKET,GENERICSOCKET)<dd>Does the same thing that the accept system call does.
Returns true if it succeeded, false otherwise.
See example in section on Interprocess Communication.
<p><dt><A NAME=bind>bind</A>(SOCKET,NAME)<dd>Does the same thing that the bind system call does.
Returns true if it succeeded, false otherwise.
NAME should be a packed address of the proper type for the socket.
See example in section on Interprocess Communication.
<p><dt><A NAME=connect>connect</A>(SOCKET,NAME)<dd>Does the same thing that the connect system call does.
Returns true if it succeeded, false otherwise.
NAME should be a package address of the proper type for the socket.
See example in section on Interprocess Communication.
<p><dt><A NAME=getpeername>getpeername</A>(SOCKET)<dd>Returns the packed sockaddr address of other end of the SOCKET connection.
<pre>
	# An internet sockaddr
	$sockaddr = 'S n a4 x8';
	$hersockaddr = getpeername(S);
	($family, $port, $heraddr) =
			<A HREF=pl-exp-conv.html#unpack>unpack</A>($sockaddr,$hersockaddr);
</pre>
<p><dt><A NAME=getsockname>getsockname</A>(SOCKET)<dd>Returns the packed sockaddr address of this end of the SOCKET connection.
<pre>
	# An internet sockaddr
	$sockaddr = 'S n a4 x8';
	$mysockaddr = getsockname(S);
	($family, $port, $myaddr) =
			<A HREF=pl-exp-conv.html#unpack>unpack</A>($sockaddr,$mysockaddr);
</pre>
<p><dt><A NAME=getsockopt>getsockopt</A>(SOCKET,LEVEL,OPTNAME)<dd>Returns the socket option requested, or undefined if there is an error.
<p><dt><A NAME=listen>listen</A>(SOCKET,QUEUESIZE)<dd>Does the same thing that the listen system call does.
Returns true if it succeeded, false otherwise.
See example in section on Interprocess Communication.
<p><dt><A NAME=msgctl>msgctl</A>(ID,CMD,ARG)<dd>Calls the System V IPC function msgctl.  If CMD is &amp;IPC_STAT, then ARG
must be a variable which will hold the returned msqid_ds structure.
Returns like ioctl: the undefined value for error, "0 but true" for
zero, or the actual return value otherwise.
<p><dt><A NAME=msgget>msgget</A>(KEY,FLAGS)<dd>Calls the System V IPC function msgget.  Returns the message queue id,
or the undefined value if there is an error.
<p><dt><A NAME=msgsnd>msgsnd</A>(ID,MSG,FLAGS)<dd>Calls the System V IPC function msgsnd to send the message MSG to the
message queue ID.  MSG must begin with the long integer message type,
which may be created with <A HREF=pl-exp-conv.html#pack>pack</A>("L", $type).  Returns true if
successful, or false if there is an error.
<p><dt><A NAME=msgrcv>msgrcv</A>(ID,VAR,SIZE,TYPE,FLAGS)<dd>Calls the System V IPC function msgrcv to receive a message from
message queue ID into variable VAR with a maximum message size of
SIZE.  Note that if a message is received, the message type will be
the first thing in VAR, and the maximum length of VAR is SIZE plus the
size of the message type.  Returns true if successful, or false if
there is an error.
<p><dt><A NAME=recv>recv</A>(SOCKET,SCALAR,LEN,FLAGS)<dd>Receives a message on a socket.
Attempts to receive LENGTH bytes of data into variable SCALAR from the specified
SOCKET filehandle.
Returns the address of the sender, or the undefined value if there's an error.
SCALAR will be grown or shrunk to the length actually read.
Takes the same flags as the system call of the same name.
<p><dt><A NAME=semctl>semctl</A>(ID,SEMNUM,CMD,ARG)<dd>Calls the System V IPC function semctl.  If CMD is &amp;IPC_STAT or
&amp;GETALL, then ARG must be a variable which will hold the returned
semid_ds structure or semaphore value array.  Returns like ioctl: the
undefined value for error, "0 but true" for zero, or the actual return
value otherwise.
<p><dt><A NAME=semget>semget</A>(KEY,NSEMS,SIZE,FLAGS)<dd>Calls the System V IPC function semget.  Returns the semaphore id, or
the undefined value if there is an error.
<p><dt><A NAME=semop>semop</A>(KEY,OPSTRING)<dd>Calls the System V IPC function semop to perform semaphore operations
such as signaling and waiting.  OPSTRING must be a packed array of
semop structures.  Each semop structure can be generated with
'pack("sss", $semnum, $semop, $semflag)'.  The number of semaphore
operations is implied by the length of OPSTRING.  Returns true if
successful, or false if there is an error.  As an example, the
following code waits on semaphore $semnum of semaphore id $semid:
<pre>
	$semop = <A HREF=pl-exp-conv.html#pack>pack</A>("sss", $semnum, -1, 0);
	<A HREF=pl-exp-sys.html#die>die</A> "Semaphore trouble: $!\n" unless semop($semid, $semop);
</pre>
To signal the semaphore, replace "-1" with "1".
<p><dt><A NAME=send>send</A>(SOCKET,MSG,FLAGS,TO)<dt><A NAME=send(SOCKET,MSG,FLAGS)>send(SOCKET,MSG,FLAGS)</A><dd>
Sends a message on a socket.
Takes the same flags as the system call of the same name.
On unconnected sockets you must specify a destination to send TO.
Returns the number of characters sent, or the undefined value if
there is an error.
<p><dt><A NAME=setsockopt>setsockopt</A>(SOCKET,LEVEL,OPTNAME,OPTVAL)<dd>Sets the socket option requested.
Returns undefined if there is an error.
OPTVAL may be specified as undef if you don't want to pass an argument.
<p><dt><A NAME=shmctl>shmctl</A>(ID,CMD,ARG)<dd>Calls the System V IPC function shmctl.  If CMD is &amp;IPC_STAT, then ARG
must be a variable which will hold the returned shmid_ds structure.
Returns like ioctl: the undefined value for error, "0 but true" for
zero, or the actual return value otherwise.
<p><dt><A NAME=shmget>shmget</A>(KEY,SIZE,FLAGS)<dd>Calls the System V IPC function shmget.  Returns the shared memory
segment id, or the undefined value if there is an error.
<p><dt><A NAME=shmread>shmread</A>(ID,VAR,POS,SIZE)<dt><A NAME=shmwrite(ID,STRING,POS,SIZE)>shmwrite(ID,STRING,POS,SIZE)</A><dd>
Reads or writes the System V shared memory segment ID starting at
position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.  When reading, VAR must be a variable which
will hold the data read.  When writing, if STRING is too long,
only SIZE bytes are used; if STRING is too short, nulls are
written to fill out SIZE bytes.  Return true if successful, or
false if there is an error.
<p><dt><A NAME=shutdown>shutdown</A>(SOCKET,HOW)<dd>Shuts down a socket connection in the manner indicated by HOW, which has
the same interpretation as in the system call of the same name.
<p><dt><A NAME=socket>socket</A>(SOCKET,DOMAIN,TYPE,PROTOCOL)<dd>Opens a socket of the specified kind and attaches it to filehandle SOCKET.
DOMAIN, TYPE and PROTOCOL are specified the same as for the system call
of the same name.
You may need to run h2ph on sys/socket.h to get the proper values handy
in a perl library file.
Return true if successful.
See the example in the section on Interprocess Communication.
<p><dt><A NAME=socketpair>socketpair</A>(SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL)<dd>Creates an unnamed pair of sockets in the specified domain, of the specified
type.
DOMAIN, TYPE and PROTOCOL are specified the same as for the system call
of the same name.
If unimplemented, yields a fatal error.
Return true if successful.

</dl>
