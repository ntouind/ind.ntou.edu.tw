<title>PERL -- Predefined Names</title>
<H3>Predefined Names</H3>
The following names have special meaning to
<I>perl</I>.
I could have used alphabetic symbols for some of these, but I didn't want
to take the chance that someone would say <A HREF=pl-exp-misc.html#reset>reset</A> "a-zA-Z" and wipe them all
out.
You'll just have to suffer along with these silly symbols.
Most of them have reasonable mnemonics, or analogues in one of the shells.
<dl compact>
<p><dt><A NAME=$_>$_</A><dd>The default input and pattern-searching space.
The following pairs are equivalent:
<pre>
	<A HREF=pl-compound.html#while>while</A> (&lt;&gt;) {...	# only equivalent in <A HREF=pl-compound.html#while>while</A>!
	<A HREF=pl-compound.html#while>while</A> ($_ = &lt;&gt;) {...

	/^Subject:/
	$_ <A HREF=pl-exp-op.html#=~>=~</A> /^Subject:/

	y/a-z/A-Z/
	$_ <A HREF=pl-exp-op.html#=~>=~</A> y/a-z/A-Z/

	chop
	<A HREF=pl-exp-str.html#chop>chop</A>($_)
</pre> 
(Mnemonic: underline is understood in certain operations.)
<p><dt><A NAME=$.>$.</A><dd>The current input line number of the last filehandle that was read.
Readonly.
Remember that only an explicit <A HREF=pl-exp-io.html#close>close</A> on the filehandle resets the line number.
Since &lt;&gt; never does an explicit close, line numbers increase across ARGV files
(but see examples under <A HREF=pl-exp-io.html#eof>eof</A>).
(Mnemonic: many programs use . to mean the current line number.)
<p><dt><A NAME=$/>$/</A><dd>The input record separator, newline by default.
Works like
<I>awk</I>'s
RS variable, including treating blank lines as delimiters
if set to the null string.
You may set it to a multicharacter string to match a multi-character
delimiter.
Note that setting it to "\n\n" means something slightly different
than setting it to "", if the file contains consecutive blank lines.
Setting it to "" will treat two or more consecutive blank lines as a single
blank line.
Setting it to "\n\n" will blindly assume that the next input character
belongs to the next paragraph, even if it's a newline.
(Mnemonic: / is used to delimit line boundaries when quoting poetry.)
<p><dt><A NAME=$,>$,</A><dd>The output field separator for the <A HREF=pl-exp-io.html#print>print</A> operator.
Ordinarily the <A HREF=pl-exp-io.html#print>print</A> operator simply prints out the comma separated fields
you specify.
In order to get behavior more like
<I>awk</I>,
set this variable as you would set
<I>awk</I>'s
OFS variable to specify what is printed between fields.
(Mnemonic: what is printed when there is a , in your <A HREF=pl-exp-io.html#print>print</A> statement.)
<p><dt><A NAME=$"">$""</A><dd>This is like $, except that it applies to array values interpolated into
a double-quoted string (or similar interpreted string).
Default is a space.
(Mnemonic: obvious, I think.)
<p><dt><A NAME=$\>$\</A><dd>The output record separator for the <A HREF=pl-exp-io.html#print>print</A> operator.
Ordinarily the <A HREF=pl-exp-io.html#print>print</A> operator simply prints out the comma separated fields
you specify, with no trailing newline or record separator assumed.
In order to get behavior more like
<I>awk</I>,
set this variable as you would set
<I>awk</I>'s
ORS variable to specify what is printed at the end of the <A HREF=pl-exp-io.html#print>print</A>.
(Mnemonic: you set $\ instead of adding \n at the end of the <A HREF=pl-exp-io.html#print>print</A>.
Also, it's just like /, but it's what you get "back" from
<I>perl</I>.)
<p><dt><A NAME=$#>$#</A><dd>The output format for printed numbers.
This variable is a half-hearted attempt to emulate
<I>awk</I>'s
OFMT variable.
There are times, however, when
<I>awk</I>
and
<I>perl</I>
have differing notions of what
is in fact numeric.
Also, the initial value is %.20g rather than %.6g, so you need to set $#
explicitly to get
<I>awk</I>'s
value.
(Mnemonic: # is the number sign.)
<p><dt><A NAME=$%>$%</A><dd>The current page number of the currently selected output channel.
(Mnemonic: % is page number in nroff.)
<p><dt><A NAME=$=>$=</A><dd>The current page length (printable lines) of the currently selected output
channel.
Default is 60.
(Mnemonic: = has horizontal lines.)
<p><dt><A NAME=$->$-</A><dd>The number of lines left on the page of the currently selected output channel.
(Mnemonic: lines_on_page - lines_printed.)
<p><dt><A NAME=$~>$~</A><dd>The name of the current report format for the currently selected output
channel.
Default is name of the filehandle.
(Mnemonic: brother to $^.)
<p><dt><A NAME=$^>$^</A><dd>The name of the current top-of-page format for the currently selected output
channel.
Default is name of the filehandle with "_TOP" appended.
(Mnemonic: points to top of page.)
<p><dt><A NAME=$|>$|</A><dd>If set to nonzero, forces a flush after every <A HREF=pl-exp-io.html#write>write</A> or print on the currently
selected output channel.
Default is 0.
Note that
<I>STDOUT</I>
will typically be line buffered if output is to the
terminal and block buffered otherwise.
Setting this variable is useful primarily when you are outputting to a pipe,
such as when you are running a
<I>perl</I>
script under rsh and want to see the
output as it's happening.
(Mnemonic: when you want your pipes to be piping hot.)
<p><dt><A NAME=$$>$$</A><dd>The process number of the
<I>perl</I>
running this script.
(Mnemonic: same as shells.)
<p><dt><A NAME=$?>$?</A><dd>The status returned by the last <A HREF=pl-exp-io.html#pipe>pipe</A> close, backtick (\`\`) command or
<I>system</I>
operator.
Note that this is the status word returned by the wait() system
call, so the exit value of the subprocess is actually ($? &gt;&gt; 8).
$? &amp; 255 gives which signal, if any, the process died from, and whether
there was a core dump.
(Mnemonic: similar to sh and ksh.)
<p><dt><A NAME=$&amp;>$&amp;</A><dd>The string matched by the last successful pattern match
(not counting any matches hidden
within a BLOCK or <A HREF=pl-exp-str.html#eval>eval</A> enclosed by the current BLOCK).
(Mnemonic: like &amp; in some editors.)
<p><dt><A NAME=$\`>$\`</A><dd>The string preceding whatever was matched by the last successful pattern match
(not counting any matches hidden within a BLOCK or <A HREF=pl-exp-str.html#eval>eval</A> enclosed by the current
BLOCK).
(Mnemonic: \` often precedes a quoted string.)
<p><dt><A NAME=$'>$'</A><dd>The string following whatever was matched by the last successful pattern match
(not counting any matches hidden within a BLOCK or <A HREF=pl-exp-str.html#eval>eval</A> enclosed by the current
BLOCK).
(Mnemonic: ' often follows a quoted string.)
Example:
<pre>
	$_ = 'abcdefghi';
	/def/;
	<A HREF=pl-exp-io.html#print>print</A> "$\`:$&amp;:$'\n";  	# prints abc:def:ghi
</pre>
<p><dt><A NAME=$+>$+</A><dd>The last bracket matched by the last search pattern.
This is useful if you don't know which of a set of alternative patterns
matched.
For example:
<pre>
    /Version: (.*)|Revision: (.*)/ &amp;&amp; ($rev = $+);
</pre>
(Mnemonic: be positive and forward looking.)
<p><dt><A NAME=$*>$*</A><dd>Set to 1 to do multiline matching within a string, 0 to tell
<I>perl</I>
that it can assume that strings contain a single line, for the purpose
of optimizing pattern matches.
Pattern matches on strings containing multiple newlines can produce confusing
results when $* is 0.
Default is 0.
(Mnemonic: * matches multiple things.)
Note that this variable only influences the interpretation of ^ and $.
A literal newline can be searched for even when $* == 0.
<p><dt><A NAME=$0>$0</A><dd>Contains the name of the file containing the
<I>perl</I>
script being executed.
Assigning to $0 modifies the argument area that the ps(1) program sees.
(Mnemonic: same as sh and ksh.)
<p><dt><A NAME=$ltdigitgt>$&lt;digit&gt;</A><dd>Contains the subpattern from the corresponding set of parentheses in the last
pattern matched, not counting patterns matched in nested blocks that have
been exited already.
(Mnemonic: like \digit.)
<p><dt><A NAME=$[>$[</A><dd>The index of the first element in an array, and of the first character in
a substring.
Default is 0, but you could set it to 1 to make
<I>perl</I>
behave more like
<I>awk</I>
(or Fortran)
when subscripting and when evaluating the <A HREF=pl-exp-str.html#index>index</A>() and <A HREF=pl-exp-str.html#substr>substr</A>() functions.
(Mnemonic: [ begins subscripts.)
<p><dt><A NAME=$]>$]</A><dd>The string printed out when you say "perl -v".
It can be used to determine at the beginning of a script whether the perl
interpreter executing the script is in the right range of versions.
If used in a numeric context, returns the version + patchlevel / 1000.
Example:
<pre>
	# see if <A HREF=pl-exp-io.html#getc>getc</A> is available
        ($version,$patchlevel) =
		 $] <A HREF=pl-exp-op.html#=~>=~</A> /(\d+\.\d+).*\nPatch level: (\d+)/;
        <A HREF=pl-exp-io.html#print>print</A> STDERR "(No filename completion available.)\n"
		 <A HREF=pl-compound.html#if>if</A> $version * 1000 + $patchlevel &lt; 2016;
</pre>
or, used numerically,
<pre>
	<A HREF=pl-exp-sys.html#warn>warn</A> "No checksumming!\n" <A HREF=pl-compound.html#if>if</A> $] &lt; 3.019;
</pre>
(Mnemonic: Is this version of perl in the right bracket?)
<p><dt><A NAME=$;>$;</A><dd>The subscript separator for multi-dimensional array emulation.
If you refer to an associative array element as
<pre>	$foo{$a,$b,$c}
</pre>
it really means
<pre>
	$foo{join($;, $a, $b, $c)}
</pre>
But don't put
<pre>
	@foo{$a,$b,$c}		# a slice--note the @
</pre>
which means
<pre>
	($foo{$a},$foo{$b},$foo{$c})
</pre>
Default is "\034", the same as SUBSEP in
<I>awk</I>.
Note that if your keys contain binary data there might not be any safe
value for $;.
(Mnemonic: comma (the syntactic subscript separator) is a semi-semicolon.
Yeah, I know, it's pretty lame, but $, is already taken for something more
important.)
<p><dt><A NAME=$!>$!</A><dd>If used in a numeric context, yields the current value of errno, with all the
usual caveats.
(This means that you shouldn't depend on the value of $! to be anything
in particular unless you've gotten a specific error return indicating a
system error.)
If used in a string context, yields the corresponding system error string.
You can assign to $! in order to set errno
if, for instance, you want $! to return the string for error n, or you want
to set the exit value for the <A HREF=pl-exp-sys.html#die>die</A> operator.
(Mnemonic: What just went bang?)
<p><dt><A NAME=$@>$@</A><dd>The perl syntax error message from the last <A HREF=pl-exp-str.html#eval>eval</A> command.
If null, the last <A HREF=pl-exp-str.html#eval>eval</A> parsed and executed correctly (although the operations
you invoked may have failed in the normal fashion).
(Mnemonic: Where was the syntax error "at"?)
<p><dt><A NAME=$lt>$&lt;</A><dd>The real uid of this process.
(Mnemonic: it's the uid you came FROM, if you're running setuid.)
<p><dt><A NAME=$gt>$&gt;</A><dd>The effective uid of this process.
Example:
<pre>
	$&lt; = $&gt;;	# set real uid to the effective uid
	($&lt;,$&gt;) = ($&gt;,$&lt;);	# swap real and effective uid
</pre>
(Mnemonic: it's the uid you went TO, if you're running setuid.)
Note: $&lt; and $&gt; can only be swapped on machines supporting setreuid().
<p><dt><A NAME=$(>$(</A><dd>The real gid of this process.
If you are on a machine that supports membership in multiple groups
simultaneously, gives a space separated list of groups you are in.
The first number is the one returned by getgid(), and the subsequent ones
by getgroups(), one of which may be the same as the first number.
(Mnemonic: parentheses are used to GROUP things.
The real gid is the group you LEFT, if you're running setgid.)
<p><dt><A NAME=$)>$)</A><dd>The effective gid of this process.
If you are on a machine that supports membership in multiple groups
simultaneously, gives a space separated list of groups you are in.
The first number is the one returned by getegid(), and the subsequent ones
by getgroups(), one of which may be the same as the first number.
(Mnemonic: parentheses are used to GROUP things.
The effective gid is the group that's RIGHT for you, if you're running setgid.)
<p>
Note: $&lt;, $&gt;, $( and $) can only be set on machines that support the
corresponding set[re][ug]id() routine.
$( and $) can only be swapped on machines supporting setregid().
<p><dt><A NAME=$:>$:</A><dd>The current set of characters after which a string may be broken to
fill continuation fields (starting with ^) in a format.
Default is "\ \n-", to break on whitespace or hyphens.
(Mnemonic: a "colon" in poetry is a part of a line.)
<p><dt><A NAME=$^D>$^D</A><dd>The current value of the debugging flags.
(Mnemonic: value of
<B>-D</B>
switch.)
<p><dt><A NAME=$^F>$^F</A><dd>The maximum system file descriptor, ordinarily 2.  System file descriptors
are passed to subprocesses, while higher file descriptors are not.
During an open, system file descriptors are preserved even if the open
fails.  Ordinary file descriptors are closed before the <A HREF=pl-exp-io.html#open>open</A> is attempted.
<p><dt><A NAME=$^I>$^I</A><dd>The current value of the inplace-edit extension.
Use <A HREF=pl-exp-misc.html#undef>undef</A> to disable inplace editing.
(Mnemonic: value of
<B>-i</B>
switch.)
<p><dt><A NAME=$^L>$^L</A><dd>What formats output to perform a formfeed.  Default is \f.
<p><dt><A NAME=$^P>$^P</A><dd>The internal flag that the debugger clears so that it doesn't
debug itself.  You could conceivable disable debugging yourself
by clearing it.
<p><dt><A NAME=$^T>$^T</A><dd>The time at which the script began running, in seconds since the epoch.
The values returned by the
<B>-M ,</B>
<B>-A</B>
and
<B>-C</B>
filetests are based on this value.
<p><dt><A NAME=$^W>$^W</A><dd>The current value of the warning switch.
(Mnemonic: related to the
<B>-w</B>
switch.)
<p><dt><A NAME=$^X>$^X</A><dd>The name that Perl itself was executed as, from argv[0].
<p><dt><A NAME=$ARGV>$ARGV</A><dd>contains the name of the current file when reading from &lt;&gt;.
<p><dt><A NAME=@ARGV>@ARGV</A><dd>The array ARGV contains the command line arguments intended for the script.
Note that $#ARGV is the generally number of arguments minus one, since
$ARGV[0] is the first argument, NOT the command name.
See $0 for the command name.
<p><dt><A NAME=@inc>@INC</A><dd>The array INC contains the list of places to look for
<I>perl</I>
scripts to be
evaluated by the "<A HREF=pl-exp-flow.html#do>do</A> EXPR" command or the "<A HREF=pl-exp-misc.html#require>require</A>" command.
It initially consists of the arguments to any
<B>-I</B>
command line switches, followed
by the default
<I>perl</I>
library, probably "/usr/local/lib/perl",
followed by ".", to represent the current directory.
<p><dt><A NAME=%INC>%INC</A><dd>The associative array INC contains entries for each filename that has
been included via "<A HREF=pl-exp-flow.html#do>do</A>" or "<A HREF=pl-exp-misc.html#require>require</A>".
The key is the filename you specified, and the value is the location of
the file actually found.
The "<A HREF=pl-exp-misc.html#require>require</A>" command uses this array to determine whether
a given file has already been included.
<p><dt><A NAME=$ENV{expr}>$ENV{expr}</A><dd>The associative array ENV contains your current environment.
Setting a value in ENV changes the environment for child processes.
<p><dt><A NAME=$SIG{expr}>$SIG{expr}</A><dd>The associative array SIG is used to set signal handlers for various signals.
Example:
<pre>
	sub handler {	# 1st argument is signal name
		<A HREF=pl-exp-misc.html#local>local</A>($sig) = @_;
		<A HREF=pl-exp-io.html#print>print</A> "Caught a SIG$sig--shutting down\n";
		<A HREF=pl-exp-io.html#close>close</A>(LOG);
		<A HREF=pl-exp-sys.html#exit>exit</A>(0);
	}

	$SIG{'INT'} = 'handler';
	$SIG{'QUIT'} = 'handler';
	...
	$SIG{'INT'} = 'DEFAULT';	# restore default action
	$SIG{'QUIT'} = 'IGNORE';	# ignore SIGQUIT
</pre>
The SIG array only contains values for the signals actually set within
the perl script.
</dl>
