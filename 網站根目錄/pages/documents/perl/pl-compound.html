<title>PERL -- Compound statements</title>
<H3>Compound statements</H3>
In
<I>perl</I>,
a sequence of commands may be treated as one command by enclosing it
in curly brackets.
We will call this a BLOCK.
<P>
The following compound commands may be used to control flow:
<pre>
	if (EXPR) BLOCK
	if (EXPR) BLOCK else BLOCK
	if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
	LABEL while (EXPR) BLOCK
	LABEL while (EXPR) BLOCK continue BLOCK
	LABEL for (EXPR; EXPR; EXPR) BLOCK
	LABEL foreach VAR (ARRAY) BLOCK
	LABEL BLOCK continue BLOCK
</pre>
Note that, unlike C and Pascal, these are defined in terms of BLOCKs, not
statements.
This means that the curly brackets are <I>required</I>--no dangling statements allowed.
If you want to write conditionals without curly brackets there are several
other ways to do it.
The following all do the same thing:
<pre>
	if (!<A HREF=pl-exp-io.html#open>open</A>(foo)) { <A HREF=pl-exp-sys.html#die>die</A> "Can't <A HREF=pl-exp-io.html#open>open</A> $foo: <A HREF=pl-predef.html#$!>$!</A>"; }
	<A HREF=pl-exp-sys.html#die>die</A> "Can't <A HREF=pl-exp-io.html#open>open</A> $foo: <A HREF=pl-predef.html#$!>$!</A>" unless <A HREF=pl-exp-io.html#open>open</A>(foo);
	<A HREF=pl-exp-io.html#open>open</A>(foo) || <A HREF=pl-exp-sys.html#die>die</A> "Can't <A HREF=pl-exp-io.html#open>open</A> $foo: <A HREF=pl-predef.html#$!>$!</A>";	# foo or bust!
	<A HREF=pl-exp-io.html#open>open</A>(foo) ? 'hi mom' : <A HREF=pl-exp-sys.html#die>die</A> "Can't <A HREF=pl-exp-io.html#open>open</A> $foo: <A HREF=pl-predef.html#$!>$!</A>";
				# a bit exotic, that last one
</pre>
<P>
The
<A NAME=if><I>if</I></A>
statement is straightforward.
Since BLOCKs are always bounded by curly brackets, there is never any
ambiguity about which
<I>if</I>
an
<I>else</I>
goes with.
If you use
<I>unless</I>
in place of
<I>if</I>,
the sense of the test is reversed.
<P>
The
<A NAME=while><I>while</I></A>
statement executes the block as long as the expression is true
(does not evaluate to the null string or 0).
The LABEL is optional, and if present, consists of an identifier followed by
a colon.
The LABEL identifies the loop for the loop control statements
<A HREF="pl-exp-flow.html#next"><I>next</I></A>,
<A HREF="pl-exp-flow.html#last"><I>last</I></A>,
and
<A HREF="pl-exp-flow.html#redo"><I>redo</I></A>.
If there is a
<A NAME=continue><I>continue</I></A>
BLOCK, it is always executed just before
the conditional is about to be evaluated again, similarly to the third part
of a
<I>for</I>
loop in C.
Thus it can be used to increment a loop variable, even when the loop has
been continued via the
<I>next</I>
statement (similar to the C "continue" statement).
<P>
If the word
<I>while</I>
is replaced by the word
<I>until</I>,
the sense of the test is reversed, but the conditional is still tested before
the first iteration.
<P>
In either the
<I>if</I>
or the
<I>while</I>
statement, you may replace "(EXPR)" with a BLOCK, and the conditional
is true if the value of the last command in that block is true.
<P>
The
<A NAME=for><I>for</I></A>
loop works exactly like the corresponding
<I>while</I>
loop:
<pre>
	for ($i = 1; $i &lt; 10; $i++) {
		...
	}
</pre>
is the same as
<pre>
	$i = 1;
	while ($i &lt; 10) {
		...
	} continue {
		$i++;
	}</pre>
<P>
The <A NAME=foreach>foreach</A> loop iterates over a normal array value and sets the variable
VAR to be each element of the array in turn.
The variable is implicitly local to the loop, and regains its former value
upon exiting the loop.
The "foreach" keyword is actually identical to the "for" keyword,
so you can use "foreach" for readability or "for" for brevity.
If VAR is omitted, <A HREF=pl-predef.html#$_>$_</A> is set to each value.
If ARRAY is an actual array (as opposed to an expression returning an array
value), you can modify each element of the array
by modifying VAR inside the loop.
Examples:
<pre>
	for (@ary) { s/foo/bar/; }

	foreach $elem (@elements) {
		$elem *= 2;
	}

	for ((10,9,8,7,6,5,4,3,2,1,'BOOM')) {
		<A HREF=pl-exp-io.html#print>print</A> $_, "\n"; <A HREF=pl-exp-sys.html#sleep>sleep</A>(1);
	}

	for (1..15) { <A HREF=pl-exp-io.html#print>print</A> "Merry Christmas\n"; }

	foreach $item (<A HREF=pl-exp-arr.html#split>split</A>(/:[\\\n:]*/, $ENV{'TERMCAP'})) {
		<A HREF=pl-exp-io.html#print>print</A> "Item: $item\n";
	}
</pre>
<P>
The BLOCK by itself (labeled or not) is equivalent to a loop that executes
once.
Thus you can use any of the loop control statements in it to leave or
restart the block.
The
<I>continue</I>
block is optional.
This construct is particularly nice for doing case structures.
<pre>
	foo: {
		if (/^abc/) { $abc = 1; <A HREF=pl-exp-flow.html#last>last</A> foo; }
		if (/^def/) { $def = 1; <A HREF=pl-exp-flow.html#last>last</A> foo; }
		if (/^xyz/) { $xyz = 1; <A HREF=pl-exp-flow.html#last>last</A> foo; }
		$nothing = 1;
	}
</pre>
There is no official switch statement in perl, because there
are already several ways to write the equivalent.
In addition to the above, you could write
<pre>
	foo: {
		$abc = 1, <A HREF=pl-exp-flow.html#last>last</A> foo  if /^abc/;
		$def = 1, <A HREF=pl-exp-flow.html#last>last</A> foo  if /^def/;
		$xyz = 1, <A HREF=pl-exp-flow.html#last>last</A> foo  if /^xyz/;
		$nothing = 1;
	}
</pre>
or
<pre>
	foo: {
		/^abc/ &amp;&amp; <A HREF=pl-exp-flow.html#do>do</A> { $abc = 1; <A HREF=pl-exp-flow.html#last>last</A> foo; };
		/^def/ &amp;&amp; <A HREF=pl-exp-flow.html#do>do</A> { $def = 1; <A HREF=pl-exp-flow.html#last>last</A> foo; };
		/^xyz/ &amp;&amp; <A HREF=pl-exp-flow.html#do>do</A> { $xyz = 1; <A HREF=pl-exp-flow.html#last>last</A> foo; };
		$nothing = 1;
	}
</pre>
or
<pre>
	foo: {
		/^abc/ &amp;&amp; ($abc = 1, <A HREF=pl-exp-flow.html#last>last</A> foo);
		/^def/ &amp;&amp; ($def = 1, <A HREF=pl-exp-flow.html#last>last</A> foo);
		/^xyz/ &amp;&amp; ($xyz = 1, <A HREF=pl-exp-flow.html#last>last</A> foo);
		$nothing = 1;
	}
</pre>
or even
<pre>
	if (/^abc/)
		{ $abc = 1; }
	elsif (/^def/)
		{ $def = 1; }
	elsif (/^xyz/)
		{ $xyz = 1; }
	else
		{$nothing = 1;}
</pre>
As it happens, these are all optimized internally to a switch structure,
so perl jumps directly to the desired statement, and you needn't worry
about perl executing a lot of unnecessary statements when you have a string
of 50 elsifs, as long as you are testing the same simple scalar variable
using ==, eq, or pattern matching as above.
(If you're curious as to whether the optimizer has done this for a particular
case statement, you can use the -D1024 switch to list the syntax tree
before execution.)
