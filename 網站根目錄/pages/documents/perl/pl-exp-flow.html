<title>PERL -- Flow Control Operations</title>
<H3>Flow Control Operations</H3>

<dl compact>
<p><dt><A NAME=do>do</A> BLOCK<dd>Returns the value of the last command in the sequence of commands indicated
by BLOCK.
When modified by a loop modifier, executes the BLOCK once before testing the
loop condition.
(On other statements the loop modifiers test the conditional first.)
<p><dt><A NAME=do>do</A> SUBROUTINE (LIST)<dd>Executes a SUBROUTINE declared by a
<I>sub</I>
declaration, and returns the value
of the last expression evaluated in SUBROUTINE.
If there is no subroutine by that name, produces a fatal error.
(You may use the "<A HREF=pl-exp-misc.html#defined>defined</A>" operator to determine if a subroutine
exists.)
If you pass arrays as part of LIST you may wish to pass the length
of the array in front of each array.
(See the section on <A HREF="pl-sub.html">subroutines</A> later on.)
The parentheses are required to avoid confusion with the "do EXPR"
form.
<p>
SUBROUTINE may also be a single scalar variable, in which case
the name of the subroutine to execute is taken from the variable.
<p>
As an alternate (and preferred) form,
you may call a subroutine by prefixing the name with
an ampersand: &amp;foo(@args).
If you aren't passing any arguments, you don't have to use parentheses.
If you omit the parentheses, no @_ array is passed to the subroutine.
The &amp; form is also used to specify subroutines to the <A HREF=pl-exp-misc.html#defined>defined</A> and undef
operators:
<pre>
	<A HREF=pl-compound.html#if>if</A> (defined &amp;$var) { &amp;$var($parm); <A HREF=pl-exp-misc.html#undef>undef</A> &amp;$var; }
</pre>
<p><dt><A NAME=do>do</A> EXPR<dd>Uses the value of EXPR as a filename and executes the contents of the file
as a
<I>perl</I>
script.
Its primary use is to include subroutines from a
<I>perl</I>
subroutine library.
<pre>
	do 'stat.pl';

is just like

	<A HREF=pl-exp-str.html#eval>eval</A> \`cat stat.pl\`;
</pre>
except that it's more efficient, more concise, keeps track of the current
filename for error messages, and searches all the
<B>-I</B>
libraries if the file
isn't in the current directory (see also the 
<A HREF="pl-predef.html#@inc">@INC</A> array in 
<A HREF="pl-predef.html">Predefined Names</A>).
It's the same, however, in that it does reparse the file every time you
call it, so if you are going to use the file inside a loop you might prefer
to use -P and #include, at the expense of a little more startup time.
(The main problem with #include is that cpp doesn't grok # comments--a
workaround is to use ";#" for standalone comments.)
Note that the following are NOT equivalent:
<pre>
	do $foo;	# eval a file
	do $foo();	# call a subroutine
</pre>
Note that inclusion of library routines is better done with
the "<A HREF=pl-exp-misc.html#require>require</A>" operator.
<p><dt><A NAME=goto>goto</A> LABEL<dd>Finds the statement labeled with LABEL and resumes execution there.
Currently you may only go to statements in the main body of the program
that are not nested inside a do {} construct.
This statement is not implemented very efficiently, and is here only to make
the
<I>sed</I>-to- perl
translator easier.
I may change its semantics at any time, consistent with support for translated
<I>sed</I>
scripts.
Use it at your own risk.
Better yet, don't use it at all.
<p><dt><A NAME=last>last</A><dt><A NAME=last LABEL>last LABEL</A><dt>last<dd>
<I>last</I>
command is like the
<I>break</I>
statement in C (as used in loops); it immediately exits the loop in question.
If the LABEL is omitted, the command refers to the innermost enclosing loop.
The
<I>continue</I>
block, if any, is not executed:
<pre>
	line: <A HREF=pl-compound.html#while>while</A> (&lt;STDIN&gt;) {
		last line <A HREF=pl-compound.html#if>if</A> /^$/;	# exit when done with header
		...
	}
</pre>
<p><dt><A NAME=next>next</A> LABEL<dt><A NAME=next>next</A><dd>
The
<I>next</I>
command is like the
<I>continue</I>
statement in C; it starts the next iteration of the loop:
<pre>
	line: <A HREF=pl-compound.html#while>while</A> (&lt;STDIN&gt;) {
		next line <A HREF=pl-compound.html#if>if</A> /^#/;	# discard comments
		...
	}
</pre>
Note that if there were a
<I>continue</I>
block on the above, it would get executed even on discarded lines.
If the LABEL is omitted, the command refers to the innermost enclosing loop.
<p><dt><A NAME=redo>redo</A><dt>redo LABEL<dt>redo<dd>
The
<I>redo</I>
command restarts the loop block without evaluating the conditional again.
The
<I>continue</I>
block, if any, is not executed.
If the LABEL is omitted, the command refers to the innermost enclosing loop.
This command is normally used by programs that want to lie to themselves
about what was just input:
<pre>
	# a simpleminded Pascal comment stripper
	# (warning: assumes no { or } in strings)
	line: <A HREF=pl-compound.html#while>while</A> (&lt;STDIN&gt;) {
		<A HREF=pl-compound.html#while>while</A> (s|({.*}.*){.*}|$1 |) {}
		s|{.*}| |;
		<A HREF=pl-compound.html#if>if</A> (s|{.*| |) {
			$front = $_;
			<A HREF=pl-compound.html#while>while</A> (&lt;STDIN&gt;) {
				<A HREF=pl-compound.html#if>if</A> (/}/) {	# end of comment?
					s|^|$front{|;
					redo line;
				}
			}
		}
		print;
	}
</pre>
<p><dt><A NAME=return>return</A> LIST<dd>Returns from a subroutine with the value specified.
(Note that a subroutine can automatically return
the value of the last expression evaluated.
That's the preferred method--use of an explicit
<I>return</I>
is a bit slower.)
</dl>
