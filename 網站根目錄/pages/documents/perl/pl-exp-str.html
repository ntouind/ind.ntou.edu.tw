<title>PERL -- String Functions</title>
<H3>String Functions</H3>

<dl compact>
<p><dt><A NAME=chop>chop</A><dt><A NAME=chop(LIST)>chop(LIST)</A><dt>chop(VARIABLE)
<dt><A NAME=chop>chop</A> VARIABLE<dt><A NAME=chop>chop</A><dd>
Chops off the last character of a string and returns the character chopped.
It's used primarily to remove the newline from the end of an input record,
but is much more efficient than s/\n// because it neither scans nor copies
the string.
If VARIABLE is omitted, chops <A HREF=pl-predef.html#$_>$_</A>.
Example:
<pre>
	<A HREF=pl-compound.html#while>while</A> (&lt;&gt;) {
		chop;	# avoid \n on last field
		@array = <A HREF=pl-exp-arr.html#split>split</A>(/:/);
		...
	}
</pre>
You can actually chop anything that's an lvalue, including an assignment:
<pre>
	chop($cwd = \`pwd\`);
	chop($answer = &lt;STDIN&gt;);
</pre>
If you chop a list, each element is chopped.
Only the value of the last chop is returned.
<p><dt><A NAME=crypt>crypt</A>(PLAINTEXT,SALT)<dd>Encrypts a string exactly like the crypt() function in the C library.
Useful for checking the password file for lousy passwords.
Only the guys wearing white hats should do this.
<p><dt><A NAME=eval>eval</A>(EXPR)<dt>eval EXPR
<dt><A NAME=eval>eval</A> BLOCK<dd>EXPR is parsed and executed as if it were a little
<I>perl</I>
program.
It is executed in the context of the current
<I>perl</I>
program, so that
any variable settings, subroutine or format definitions remain afterwards.
The value returned is the value of the last expression evaluated, just
as with subroutines.
If there is a syntax error or runtime error, or a <A HREF=pl-exp-sys.html#die>die</A> statement is
executed, an undefined value is returned by
eval, and <A HREF=pl-predef.html#$@>$@</A> is set to the error message.
If there was no error, <A HREF=pl-predef.html#$@>$@</A> is guaranteed to be a null string.
If EXPR is omitted, evaluates <A HREF=pl-predef.html#$_>$_</A>.
The final semicolon, if any, may be omitted from the expression.
<p>
Note that, since eval traps otherwise-fatal errors, it is useful for
determining whether a particular feature
(such as <A HREF=pl-exp-io.html#dbmopen>dbmopen</A> or <A HREF=pl-exp-file.html#symlink>symlink</A>) is implemented.
It is also Perl's exception trapping mechanism, where the <A HREF=pl-exp-sys.html#die>die</A> operator is
used to raise exceptions.
<p>
If the code to be executed doesn't vary, you may use
the eval-BLOCK form to trap run-time errors without incurring
the penalty of recompiling each time.
The error, if any, is still returned in <A HREF=pl-predef.html#$@>$@</A>.
Evaluating a single-quoted string (as EXPR) has the same effect, except that
the eval-EXPR form reports syntax errors at run time via $@, whereas the
eval-BLOCK form reports syntax errors at compile time.  The eval-EXPR form
is optimized to eval-BLOCK the first time it succeeds.  (Since the replacement
side of a substitution is considered a single-quoted string when you
use the e modifier, the same optimization occurs there.)  Examples:
<pre>
	# make divide-by-zero non-fatal
	eval { $answer = $a / $b; }; <A HREF=pl-exp-sys.html#warn>warn</A> <A HREF=pl-predef.html#$@>$@</A> <A HREF=pl-compound.html#if>if</A> <A HREF=pl-predef.html#$@>$@</A>;

	# optimized to same thing after first use
	eval '$answer = $a / $b'; <A HREF=pl-exp-sys.html#warn>warn</A> <A HREF=pl-predef.html#$@>$@</A> <A HREF=pl-compound.html#if>if</A> <A HREF=pl-predef.html#$@>$@</A>;

	# a compile-time error
	eval { $answer = };

	# a run-time error
	eval '$answer =';	# sets $@
</pre>
<p><dt><A NAME=index>index</A>(STR,SUBSTR,POSITION)<dt><A NAME=index(STR,SUBSTR)>index(STR,SUBSTR)</A><dd>
Returns the position of the first occurrence of SUBSTR in STR at or after
POSITION.
If POSITION is omitted, starts searching from the beginning of the string.
The return value is based at 0, or whatever you've
set the <A HREF=pl-predef.html#$[>$[</A> variable to.
If the substring is not found, returns one less than the base, ordinarily -1.
<p><dt><A NAME=length>length</A>(EXPR)<dt><A NAME=length EXPR>length EXPR</A><dd>
Returns the length in characters of the value of EXPR.
If EXPR is omitted, returns length of <A HREF=pl-predef.html#$_>$_</A>.
<p><dt><A NAME=q>q</A>/STRING/<dt>qq/STRING/
<dt><A NAME=qx>qx</A>/STRING/<dd>These are not really functions, but simply syntactic sugar to let you
avoid putting too many backslashes into quoted strings.
The q operator is a generalized single quote, and the qq operator a
generalized double quote.
The qx operator is a generalized backquote.
Any non-alphanumeric delimiter can be used in place of /, including newline.
If the delimiter is an opening bracket or parenthesis, the final delimiter
will be the corresponding closing bracket or parenthesis.
(Embedded occurrences of the closing bracket need to be backslashed as usual.)
Examples:
<pre>
	$foo = q!I said, "You said, 'She said it.'"!;
	$bar = q('This is it.');
	$today = qx{ date };
	<A HREF=pl-predef.html#$_>$_</A> .= qq
*** The previous line contains the naughty word "<A HREF=pl-predef.html#$&amp;>$&amp;</A>".\n
		<A HREF=pl-compound.html#if>if</A> /(ibm|apple|awk)/;      # :-)
</pre>
<p><dt><A NAME=rindex>rindex</A>(STR,SUBSTR,POSITION)<dt><A NAME=rindex(STR,SUBSTR)>rindex(STR,SUBSTR)</A><dd>
Works just like index except that it
returns the position of the LAST occurrence of SUBSTR in STR.
If POSITION is specified, returns the last occurrence at or before that
position.
<p><dt><A NAME=substr>substr</A>(EXPR,OFFSET,LEN)<dt><A NAME=substr(EXPR,OFFSET)>substr(EXPR,OFFSET)</A><dd>
Extracts a substring out of EXPR and returns it.
First character is at offset 0, or whatever you've set <A HREF=pl-predef.html#$[>$[</A> to.
If OFFSET is negative, starts that far from the end of the string.
If LEN is omitted, returns everything to the end of the string.
You can use the substr() function as an lvalue, in which case EXPR must
be an lvalue.
If you assign something shorter than LEN, the string will shrink, and
if you assign something longer than LEN, the string will grow to accommodate it.
To keep the string the same length you may need to pad or chop your value using
<A HREF=pl-exp-io.html#sprintf>sprintf</A>().
</dl>