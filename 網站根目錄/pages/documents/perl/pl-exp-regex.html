<title>PERL -- Search and Modification Operations</title>
<H3>Search and Modification Operations</H3>

<dl compact>
<dt><A NAME=m>m</A>/PATTERN/gio<dt><A NAME=/PATTERN/gio>/PATTERN/gio</A><dd>
Searches a string for a pattern match, and returns true (1) or false ('').
If no string is specified via the <A HREF=pl-exp-op.html#=~>=~</A> or <A HREF=pl-exp-op.html#!~>!~</A> operator,
the <A HREF=pl-predef.html#$_>$_</A> string is searched.
(The string specified with <A HREF=pl-exp-op.html#=~>=~</A> need not be an lvalue--it may be the result of an expression evaluation, but remember the <A HREF=pl-exp-op.html#=~>=~</A> binds rather tightly.)
See also the section on regular expressions.
<p>
If / is the delimiter then the initial 'm' is optional.
With the 'm' you can use any pair of non-alphanumeric characters
as delimiters.
This is particularly useful for matching Unix path names that contain '/'.
If the final delimiter is followed by the optional letter 'i', the matching is
done in a case-insensitive manner.
PATTERN may contain references to scalar variables, which will be interpolated
(and the pattern recompiled) every time the pattern search is evaluated.
(Note that $) and <A HREF=pl-predef.html#$|>$|</A> may not be interpolated because they look like end-of-string tests.)
If you want such a pattern to be compiled only once, add an "o" after
the trailing delimiter.
This avoids expensive run-time recompilations, and
is useful when the value you are interpolating won't change over the
life of the script.
If the PATTERN evaluates to a null string, the most recent successful
regular expression is used instead.
<p>
If used in a context that requires an array value, a pattern match returns an
array consisting of the subexpressions matched by the parentheses in the
pattern,
i.e. ($1, $2, $3...).
It does NOT actually set $1, $2, etc. in this case, nor does it set $+, $`, $&amp;
or <A HREF=pl-predef.html#$'>$'</A>.
If the match fails, a null array is returned.
If the match succeeds, but there were no parentheses, an array value of (1)
is returned.
<p>
Examples:
<pre>
    <A HREF=pl-exp-io.html#open>open</A>(tty, '/dev/tty');
    &lt;tty&gt; <A HREF=pl-exp-op.html#=~>=~</A> /^y/i &amp;&amp; <A HREF=pl-exp-flow.html#do>do</A> foo();	# <A HREF=pl-exp-flow.html#do>do</A> foo if desired

    <A HREF=pl-compound.html#if>if</A> (/Version: *([0-9.]*)/) { $version = $1; }

    <A HREF=pl-exp-flow.html#next>next</A> <A HREF=pl-compound.html#if>if</A> m#^/usr/spool/uucp#;

    # poor man's grep
    $arg = shift;
    <A HREF=pl-compound.html#while>while</A> (&lt;&gt;) {
	    <A HREF=pl-exp-io.html#print>print</A> <A HREF=pl-compound.html#if>if</A> /$arg/o;	# compile only once
    }

    <A HREF=pl-compound.html#if>if</A> (($F1, $F2, $Etc) = ($foo <A HREF=pl-exp-op.html#=~>=~</A> /^(\S+)\s+(\S+)\s*(.*)/))
</pre>
This last example splits $foo into the first two words and the remainder
of the line, and assigns those three fields to $F1, $F2 and $Etc.
The conditional is true if any variables were assigned, i.e. if the pattern
matched.
<p>
The "g" modifier specifies global pattern matching--that is,
matching as many times as possible within the string.  How it behaves
depends on the context.  In an array context, it returns a list of
all the substrings matched by all the parentheses in the regular expression.
If there are no parentheses, it returns a list of all the matched strings,
as if there were parentheses around the whole pattern.  In a scalar context,
it iterates through the string, returning TRUE each time it matches, and
FALSE when it eventually runs out of matches.  (In other words, it remembers
where it left off last time and restarts the search at that point.)  It
presumes that you have not modified the string since the last match.
Modifying the string between matches may result in undefined behavior.
(You can actually get away with in-place modifications via <A HREF=pl-exp-str.html#substr>substr</A>()
that do not change the length of the entire string.  In general, however,
you should be using s///g for such modifications.)  Examples:
<pre>
	# array context
	($one,$five,$fifteen) = (\`uptime\` <A HREF=pl-exp-op.html#=~>=~</A> /(\d+\.\d+)/g);

	# scalar context
	<A HREF=pl-predef.html#$/>$/</A> = ""; <A HREF=pl-predef.html#$*>$*</A> = 1;
	<A HREF=pl-compound.html#while>while</A> ($paragraph = &lt;&gt;) {
	    <A HREF=pl-compound.html#while>while</A> ($paragraph <A HREF=pl-exp-op.html#=~>=~</A> /[a-z]['")]*[.!?]+['")]*\s/g) {
		$sentences++;
	    }
	}
	<A HREF=pl-exp-io.html#print>print</A> "$sentences\n";
</pre>
<p><dt><A NAME=?PATTERN?>?PATTERN?</A><dd>This is just like the /pattern/ search, except that it matches only once between
calls to the
<I>reset</I>
operator.
This is a useful optimization when you only want to see the first occurrence of
something in each file of a set of files, for instance.
Only ?? patterns local to the current package are <A HREF=pl-exp-misc.html#reset>reset</A>.
<p><dt><A NAME=s>s/PATTERN/REPLACEMENT/gieo</A><dd>Searches a string for a pattern, and if found, replaces that pattern with the
replacement text and returns the number of substitutions made.
Otherwise it returns false (0).
The "g" is optional, and if present, indicates that all occurrences
of the pattern are to be replaced.
The "i" is also optional, and if present, indicates that matching
is to be done in a case-insensitive manner.
The "e" is likewise optional, and if present, indicates that
the replacement string is to be evaluated as an expression rather than just
as a double-quoted string.
Any non-alphanumeric delimiter may replace the slashes;
if single quotes are used, no
interpretation is done on the replacement string (the e modifier overrides
this, however); if backquotes are used, the replacement string is a command
to execute whose output will be used as the actual replacement text.
If the PATTERN is delimited by bracketing quotes, the REPLACEMENT
has its own pair of quotes, which may or may not be bracketing quotes, e.g.
s(foo)(bar) or s&lt;foo&gt;/bar/.
If no string is specified via the <A HREF=pl-exp-op.html#=~>=~</A> or <A HREF=pl-exp-op.html#!~>!~</A> operator,
the <A HREF=pl-predef.html#$_>$_</A> string is searched and modified.
(The string specified with <A HREF=pl-exp-op.html#=~>=~</A> must be a scalar variable, an array element,
or an assignment to one of those, i.e. an lvalue.)
If the pattern contains a $ that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern at
run-time.
If you only want the pattern compiled once the first time the variable is
interpolated, add an "o" at the end.
If the PATTERN evaluates to a null string, the most recent successful
regular expression is used instead.
See also the section on regular expressions.
Examples:
<pre>
    s/\bgreen\b/mauve/g;		# don't change wintergreen

    $path <A HREF=pl-exp-op.html#=~>=~</A> s|/usr/bin|/usr/local/bin|;

    s/Login: $foo/Login: $bar/; # run-time pattern

    ($foo = $bar) <A HREF=pl-exp-op.html#=~>=~</A> s/bar/foo/;

    <A HREF=pl-predef.html#$_>$_</A> = 'abc123xyz';
    s/\d+/$&amp;*2/e;		# yields 'abc246xyz'
    s/\d+/sprintf("%5d",$&amp;)/e;	# yields 'abc  246xyz'
    s/\w/$&amp; x 2/eg;		# yields 'aabbcc  224466xxyyzz'

    s/([^ ]*) *([^ ]*)/$2 $1/;	# reverse 1st two fields
</pre>
(Note the use of $ instead of \ in the last example.  See section
on regular expressions.)
<p><dt><A NAME=study>study</A>(SCALAR)<dt>study SCALAR
<dt><A NAME=study>study</A><dd>Takes extra time to study SCALAR (<A HREF=pl-predef.html#$_>$_</A> if unspecified) in anticipation of
doing many pattern matches on the string before it is next modified.
This may or may not save time, depending on the nature and number of patterns
you are searching on, and on the distribution of character frequencies in
the string to be searched--you probably want to compare runtimes with and
without it to see which runs faster.
Those loops which scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.
You may have only one study active at a time--if you study a different
scalar the first is "unstudied".
(The way study works is this: a linked list of every character in the string
to be searched is made, so we know, for example, where all the 'k' characters
are.
From each search string, the rarest character is selected, based on some
static frequency tables constructed from some C programs and English text.
Only those places that contain this "rarest" character are examined.)
<p>
For example, here is a loop which inserts index producing entries before any line
containing a certain pattern:
<pre>
	<A HREF=pl-compound.html#while>while</A> (&lt;&gt;) {
		study;
		<A HREF=pl-exp-io.html#print>print</A> ".IX foo\n" <A HREF=pl-compound.html#if>if</A> /\bfoo\b/;
		<A HREF=pl-exp-io.html#print>print</A> ".IX bar\n" <A HREF=pl-compound.html#if>if</A> /\bbar\b/;
		<A HREF=pl-exp-io.html#print>print</A> ".IX blurfl\n" <A HREF=pl-compound.html#if>if</A> /\bblurfl\b/;
		...
		print;
	}
</pre>
In searching for /\bfoo\b/, only those locations in <A HREF=pl-predef.html#$_>$_</A> that contain 'f'
will be looked at, because 'f' is rarer than 'o'.
In general, this is a big win except in pathological cases.
The only question is whether it saves you more time than it took to build
the linked list in the first place.
<p>
Note that if you have to look for strings that you don't know till runtime,
you can build an entire loop as a string and eval that to avoid recompiling
all your patterns all the time.
Together with undefining <A HREF=pl-predef.html#$/>$/</A> to input entire files as one record, this can
be very fast, often faster than specialized programs like fgrep.
The following scans a list of files (@files)
for a list of words (@words), and prints out the names of those files that
contain a match:
<pre>
	$search = 'while (&lt;&gt;) { study;';
	<A HREF=pl-compound.html#foreach>foreach</A> $word (@words) {
	    $search .= "++\$seen{\$ARGV} <A HREF=pl-compound.html#if>if</A> /\\b$word\\b/;\n";
	}
	$search .= "}";
	@ARGV = @files;
	<A HREF=pl-exp-misc.html#undef>undef</A> $/;
	<A HREF=pl-exp-str.html#eval>eval</A> $search;		# this screams
	<A HREF=pl-predef.html#$/>$/</A> = "\n";		# put back to normal input delim
	<A HREF=pl-compound.html#foreach>foreach</A> $file (<A HREF=pl-exp-arr.html#sort>sort</A> <A HREF=pl-exp-arr.html#keys>keys</A>(%seen)) {
	    <A HREF=pl-exp-io.html#print>print</A> $file, "\n";
	}
</pre>
<p><dt><A NAME=tr>tr/SEARCHLIST/REPLACEMENTLIST/cds</A><dt><A NAME=y>y</A>/SEARCHLIST/REPLACEMENTLIST/cds<dd>
Translates all occurrences of the characters found in the search list with
the corresponding character in the replacement list.
It returns the number of characters replaced or deleted.
If no string is specified via the <A HREF=pl-exp-op.html#=~>=~</A> or <A HREF=pl-exp-op.html#!~>!~</A> operator,
the <A HREF=pl-predef.html#$_>$_</A> string is translated.
(The string specified with <A HREF=pl-exp-op.html#=~>=~</A> must be a scalar variable, an array element,
or an assignment to one of those, i.e. an lvalue.)
For
<I>sed</I>
devotees,
<I>y</I>
is provided as a synonym for
<I>tr</I>.
If the SEARCHLIST is delimited by bracketing quotes, the REPLACEMENTLIST
has its own pair of quotes, which may or may not be bracketing quotes, e.g.
tr[A-Z][a-z] or tr(+-*/)/ABCD/.
<p>
If the c modifier is specified, the SEARCHLIST character set is complemented.
If the d modifier is specified, any characters specified by SEARCHLIST that
are not found in REPLACEMENTLIST are deleted.
(Note that this is slightly more flexible than the behavior of some
<I>tr</I>
programs, which delete anything they find in the SEARCHLIST, period.)
If the s modifier is specified, sequences of characters that were translated
to the same character are squashed down to 1 instance of the character.
<p>
If the d modifier was used, the REPLACEMENTLIST is always interpreted exactly
as specified.
Otherwise, if the REPLACEMENTLIST is shorter than the SEARCHLIST,
the final character is replicated till it is long enough.
If the REPLACEMENTLIST is null, the SEARCHLIST is replicated.
This latter is useful for counting characters in a class, or for squashing
character sequences in a class.
<p>
Examples:
<pre>
    $ARGV[1] <A HREF=pl-exp-op.html#=~>=~</A> y/A-Z/a-z/;	\h'|3i'# canonicalize to lower case

    $cnt = tr/*/*/;		\h'|3i'# count the stars in $_

    $cnt = tr/0-9//;		\h'|3i'# count the digits in $_

    tr/a-zA-Z//s;	\h'|3i'# bookkeeper -&gt; bokeper

    ($HOST = $host) <A HREF=pl-exp-op.html#=~>=~</A> tr/a-z/A-Z/;

    y/a-zA-Z/ /cs;	\h'|3i'# change non-alphas to single space

    tr/\200-\377/\0-\177/;\h'|3i'# delete 8th bit
</pre>
</dl>
