<title>PERL -- Array and List Functions</title>
<H3>Array and List Functions</H3>

<dl compact>
<p><dt><A NAME=delete>delete</A> $ASSOC{KEY}<dd>Deletes the specified value from the specified associative array.
Returns the deleted value, or the undefined value if nothing was deleted.
Deleting from $ENV{} modifies the environment.
Deleting from an array bound to a dbm file deletes the entry from the dbm
file.
<p>
The following deletes all the values of an associative array:
<pre>
	<A HREF=pl-compound.html#foreach>foreach</A> $key (keys %ARRAY) {
		delete $ARRAY{$key};
	}
</pre>
(But it would be faster to use the
<I>reset</I>
command.
Saying <A HREF=pl-exp-misc.html#undef>undef</A> %ARRAY is faster yet.)
<p><dt><A NAME=each>each</A>(ASSOC_ARRAY)<dt><A NAME=each ASSOC_ARRAY>each ASSOC_ARRAY</A><dd>
Returns a 2 element array consisting of the key and value for the next
value of an associative array, so that you can iterate over it.
Entries are returned in an apparently random order.
When the array is entirely read, a null array is returned (which when
assigned produces a FALSE (0) value).
The next call to each() after that will start iterating again.
The iterator can be reset only by reading all the elements from the array.
You must not modify the array while iterating over it.
There is a single iterator for each associative array, shared by all
each(), keys() and values() function calls in the program.
The following prints out your environment like the printenv program, only
in a different order:
<pre>
	<A HREF=pl-compound.html#while>while</A> (($key,$value) = each %ENV) {
		<A HREF=pl-exp-io.html#print>print</A> "$key=$value\n";
	}
</pre>
See also keys() and values().
<p><dt><A NAME=grep>grep</A>(EXPR,LIST)<dd>Evaluates EXPR for each element of LIST (locally setting <A HREF=pl-predef.html#$_>$_</A> to each element)
and returns the array value consisting of those elements for which the
expression evaluated to true.
In a scalar context, returns the number of times the expression was true.
<pre>
	@foo = grep(!/^#/, @bar);    # weed out comments
</pre>
Note that, since <A HREF=pl-predef.html#$_>$_</A> is a reference into the array value, it can be
used to modify the elements of the array.
While this is useful and supported, it can cause bizarre results if
the LIST is not a named array.
<p><dt><A NAME=join>join</A>(EXPR,LIST)<dt><A NAME=join(EXPR,ARRAY)>join(EXPR,ARRAY)</A><dd>
Joins the separate strings of LIST or ARRAY into a single string with fields
separated by the value of EXPR, and returns the string.
Example:
<pre>    
    <A HREF=pl-predef.html#$_>$_</A> = join(':',
		$login,$passwd,$uid,$gid,$gcos,$home,$shell);
</pre>
See
<I>split</I>.
<p><dt><A NAME=keys>keys</A>(ASSOC_ARRAY)<dt><A NAME=keys ASSOC_ARRAY>keys ASSOC_ARRAY</A><dd>
Returns a normal array consisting of all the keys of the named associative
array.
The keys are returned in an apparently random order, but it is the same order
as either the values() or each() function produces (given that the associative array
has not been modified).
Here is yet another way to print your environment:
<pre>
	@keys = keys %ENV;
	@values = values %ENV;
	<A HREF=pl-compound.html#while>while</A> ($#keys &gt;= 0) {
		<A HREF=pl-exp-io.html#print>print</A> pop(@keys), '=', pop(@values), "\n";
	}

or how about sorted by key:

	<A HREF=pl-compound.html#foreach>foreach</A> $key (sort(keys %ENV)) {
		<A HREF=pl-exp-io.html#print>print</A> $key, '=', $ENV{$key}, "\n";
	}
</pre>
<p><dt><A NAME=pop>pop</A>(ARRAY)<dt><A NAME=pop ARRAY>pop ARRAY</A><dd>
Pops and returns the last value of the array, shortening the array by 1.
Has the same effect as
<pre>
	$tmp = $ARRAY[$#ARRAY--];
</pre>
If there are no elements in the array, returns the undefined value.
<p><dt><A NAME=push>push</A>(ARRAY,LIST)<dd>Treats ARRAY (@ is optional) as a stack, and pushes the values of LIST
onto the end of ARRAY.
The length of ARRAY increases by the length of LIST.
Has the same effect as
<pre>
    <A HREF=pl-compound.html#for>for</A> $value (LIST) {
	    $ARRAY[++$#ARRAY] = $value;
    }
</pre>
but is more efficient.
<p><dt><A NAME=reverse>reverse</A>(LIST)<dt><A NAME=reverse LIST>reverse LIST</A><dd>
In an array context, returns an array value consisting of the elements
of LIST in the opposite order.
In a scalar context, returns a string value consisting of the bytes of
the first element of LIST in the opposite order.
<p><dt><A NAME=shift>shift</A>(ARRAY)<dt>shift ARRAY
<dt><A NAME=shift>shift</A><dd>Shifts the first value of the array off and returns it,
shortening the array by 1 and moving everything down.
If there are no elements in the array, returns the undefined value.
If ARRAY is omitted, shifts the @ARGV array in the main program, and the @_
array in subroutines.
(This is determined lexically.)
See also unshift(), push() and pop().
Shift() and unshift() do the same thing to the left end of an array that push()
and pop() do to the right end.
<p><dt><A NAME=sort>sort</A>(SUBROUTINE LIST)<dt>sort(LIST)
<dt><A NAME=sort>sort</A> SUBROUTINE LIST<dt>sort BLOCK LIST
<dt><A NAME=sort>sort</A> LIST<dd>Sorts the LIST and returns the sorted array value.
Nonexistent values of arrays are stripped out.
If SUBROUTINE or BLOCK is omitted, sorts in standard string comparison order.
If SUBROUTINE is specified, gives the name of a subroutine that returns
an integer less than, equal to, or greater than 0,
depending on how the elements of the array are to be ordered.
(The <A HREF=pl-exp-op.html#&lt;=&gt;>&lt;=&gt;</A> and <A HREF=pl-exp-op.html#cmp>cmp</A> operators are extremely useful in such routines.)
SUBROUTINE may be a scalar variable name, in which case the value provides
the name of the subroutine to use.
In place of a SUBROUTINE name, you can provide a BLOCK as an anonymous,
in-line sort subroutine.
<p>
In the interests of efficiency the normal calling code for subroutines
is bypassed, with the following effects: the subroutine may not be a recursive
subroutine, and the two elements to be compared are passed into the subroutine
not via @_ but as $a and $b (see example below).
They are passed by reference so don't modify $a and $b.
<p>
Examples:
<pre>
	# sort lexically
	@articles = sort @files;

	# same thing, but with explicit sort routine
	@articles = sort {$a <A HREF=pl-exp-op.html#cmp>cmp</A> $b} @files;

	# same thing in reversed order
	@articles = sort {$b <A HREF=pl-exp-op.html#cmp>cmp</A> $a} @files;

	# sort numerically ascending
	@articles = sort {$a <A HREF=pl-exp-op.html#&lt;=&gt;>&lt;=&gt;</A> $b} @files;

	# sort numerically descending
	@articles = sort {$b <A HREF=pl-exp-op.html#&lt;=&gt;>&lt;=&gt;</A> $a} @files;

	# sort using explicit subroutine name
	sub byage {
	    $age{$a} <A HREF=pl-exp-op.html#&lt;=&gt;>&lt;=&gt;</A> $age{$b};	# presuming integers
	}
	@sortedclass = sort byage @class;

	sub reverse { $b <A HREF=pl-exp-op.html#cmp>cmp</A> $a; }
	@harry = ('dog','cat','x','Cain','Abel');
	@george = ('gone','chased','yz','Punished','Axed');
	<A HREF=pl-exp-io.html#print>print</A> sort @harry;
		# prints AbelCaincatdogx
	<A HREF=pl-exp-io.html#print>print</A> sort reverse @harry;
		# prints xdogcatCainAbel
	<A HREF=pl-exp-io.html#print>print</A> sort @george, 'to', @harry;
		# prints AbelAxedCainPunishedcatchaseddoggonetoxyz
</pre>
<p><dt><A NAME=splice>splice</A>(ARRAY,OFFSET,LENGTH,LIST)<dt>splice(ARRAY,OFFSET,LENGTH)
<dt><A NAME=splice>splice</A>(ARRAY,OFFSET)<dd>Removes the elements designated by OFFSET and LENGTH from an array, and
replaces them with the elements of LIST, if any.
Returns the elements removed from the array.
The array grows or shrinks as necessary.
If LENGTH is omitted, removes everything from OFFSET onward.
The following equivalencies hold (assuming <A HREF=pl-predef.html#$[>$[</A> == 0):
<pre>
	push(@a,$x,$y)\h'|3.5i'splice(@a,$#a+1,0,$x,$y)
	pop(@a)\h'|3.5i'splice(@a,-1)
	shift(@a)\h'|3.5i'splice(@a,0,1)
	unshift(@a,$x,$y)\h'|3.5i'splice(@a,0,0,$x,$y)
	$a[$x] = $y\h'|3.5i'splice(@a,$x,1,$y);

Example, assuming array lengths are passed before arrays:
	
	sub aeq {	# compare two array values
		<A HREF=pl-exp-misc.html#local>local</A>(@a) = splice(@_,0,shift);
		<A HREF=pl-exp-misc.html#local>local</A>(@b) = splice(@_,0,shift);
		<A HREF=pl-exp-flow.html#return>return</A> 0 unless @a == @b;	# same len?
		<A HREF=pl-compound.html#while>while</A> (@a) {
		    <A HREF=pl-exp-flow.html#return>return</A> 0 if pop(@a) <A HREF=pl-exp-op.html#ne>ne</A> pop(@b);
		}
		<A HREF=pl-exp-flow.html#return>return</A> 1;
	}
	<A HREF=pl-compound.html#if>if</A> (&amp;aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }
</pre>
<p><dt><A NAME=split>split</A>(/PATTERN/,EXPR,LIMIT)<dt>split(/PATTERN/,EXPR)
<dt><A NAME=split>split</A>(/PATTERN/)<dt><A NAME=split>split</A><dd>
Splits a string into an array of strings, and returns it.
(If not in an array context, returns the number of fields found and splits
into the @_ array.
(In an array context, you can force the split into @_
by using ?? as the pattern delimiters, but it still returns the array value.))
If EXPR is omitted, splits the <A HREF=pl-predef.html#$_>$_</A> string.
If PATTERN is also omitted, splits on whitespace (/[\ \t\n]+/).
Anything matching PATTERN is taken to be a delimiter separating the fields.
(Note that the delimiter may be longer than one character.)
If LIMIT is specified, splits into no more than that many fields (though it
may split into fewer).
If LIMIT is unspecified, trailing null fields are stripped (which
potential users of pop() would do well to remember).
A pattern matching the null string (not to be confused with a null pattern //,
which is just one member of the set of patterns matching a null string)
will split the value of EXPR into separate characters at each point it
matches that way.
For example:
<pre>
	<A HREF=pl-exp-io.html#print>print</A> join(':', split(/ */, 'hi there'));
</pre>
produces the output 'h:i:t:h:e:r:e'.
<p>
The LIMIT parameter can be used to partially split a line
<pre>
	($login, $passwd, $remainder) = split(/:/, $_, 3);
</pre>
(When assigning to a list, if LIMIT is omitted, perl supplies a LIMIT one
larger than the number of variables in the list, to avoid unnecessary work.
For the list above LIMIT would have been 4 by default.
In time critical applications it behooves you not to split into
more fields than you really need.)
<p>
If the PATTERN contains parentheses, additional array elements are created
from each matching substring in the delimiter.
<p>
	split(/([,-])/,"1-10,20");
<p>
produces the array value
<p>
	(1,'-',10,',',20)
<p>
The pattern /PATTERN/ may be replaced with an expression to specify patterns
that vary at runtime.
(To do runtime compilation only once, use /$variable/o.)
As a special case, specifying a space ('\ ') will split on white space
just as split with no arguments does, but leading white space does NOT
produce a null first field.
Thus, split('\ ') can be used to emulate
<I>awk</I>'s
default behavior, whereas
split(/\ /) will give you as many null initial fields as there are
leading spaces.
<p>
Example:
<pre>
	<A HREF=pl-exp-io.html#open>open</A>(passwd, '/etc/passwd');
	<A HREF=pl-compound.html#while>while</A> (&lt;passwd&gt;) {
		($login, $passwd, $uid, $gid, $gcos, $home, $shell)
			= split(/:/);
		...
	}
</pre>
(Note that $shell above will still have a newline on it.  
See <A HREF="pl-exp-str.html#chop">chop()</A>.)
See also
<I>join</I>.
<p><dt><A NAME=unshift>unshift</A>(ARRAY,LIST)<dd>Does the opposite of a
<I>shift</I>.
Or the opposite of a
<I>push</I>,
depending on how you look at it.
Prepends list to the front of the array, and returns the number of elements
in the new array.
<pre>
	unshift(ARGV, '-e') unless $ARGV[0] <A HREF=pl-exp-op.html#=~>=~</A> /^-/;
</pre>
<p><dt><A NAME=values>values</A>(ASSOC_ARRAY)<dt><A NAME=values ASSOC_ARRAY>values ASSOC_ARRAY</A><dd>
Returns a normal array consisting of all the values of the named associative
array.
The values are returned in an apparently random order, but it is the same order
as either the keys() or each() function would produce on the same array.
See also keys() and each().
</dl>
