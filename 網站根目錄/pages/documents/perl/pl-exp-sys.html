<title>PERL -- System Interaction Routines</title>
<H3>System Interaction Routines</H3>

<dl compact>
<p><dt><A NAME=alarm>alarm</A>(SECONDS)<dt><A NAME=alarm SECONDS>alarm SECONDS</A><dd>
Arranges to have a SIGALRM delivered to this process after the specified number
of seconds (minus 1, actually) have elapsed.  Thus, alarm(15) will cause
a SIGALRM at some point more than 14 seconds in the future.
Only one timer may be counting at once.  Each call disables the previous
timer, and an argument of 0 may be supplied to cancel the previous timer
without starting a new one.
The returned value is the amount of time remaining on the previous timer.
<p><dt><A NAME=chdir>chdir</A>(EXPR)<dt><A NAME=chdir EXPR>chdir EXPR</A><dd>
Changes the working directory to EXPR, if possible.
If EXPR is omitted, changes to home directory.
Returns 1 upon success, 0 otherwise.
See example under
<I>die</I>.
<p><dt><A NAME=chroot>chroot</A>(FILENAME)<dt><A NAME=chroot FILENAME>chroot FILENAME</A><dd>
Does the same as the system call of that name.
If you don't know what it does, don't worry about it.
If FILENAME is omitted, does chroot to <A HREF=pl-predef.html#$_>$_</A>.
<p><dt><A NAME=die>die</A>(LIST)<dt><A NAME=die LIST>die LIST</A><dd>
Outside of an eval, prints the value of LIST to
<I>STDERR</I>
and exits with the current value of $!
(errno).
If <A HREF=pl-predef.html#$!>$!</A> is 0, exits with the value of (<A HREF=pl-predef.html#$?>$?</A> &gt;&gt; 8) (\`command\` status).
If (<A HREF=pl-predef.html#$?>$?</A> &gt;&gt; 8) is 0, exits with 255.
Inside an <A HREF=pl-exp-str.html#eval>eval</A>, the error message is stuffed into <A HREF=pl-predef.html#$@>$@</A> and the <A HREF=pl-exp-str.html#eval>eval</A> is terminated
with the undefined value.
<p>
Equivalent examples:
<pre>
	die "Can't cd to spool: $!\n"
		unless chdir '/usr/spool/news';

	chdir '/usr/spool/news' || die "Can't cd to spool: $!\n" 
</pre>
<p>
If the value of EXPR does not end in a newline, the current script line
number and input line number (if any) are also printed, and a newline is
supplied.
Hint: sometimes appending ", stopped" to your message will cause it to make
better sense when the string "at foo line 123" is appended.
Suppose you are running script "canasta".
<pre>
	die "/etc/games is no good";
	die "/etc/games is no good, stopped";

produce, respectively

	/etc/games is no good at canasta line 123.
	/etc/games is no good, stopped at canasta line 123.
</pre>
See also
<I>exit</I>.
<p><dt><A NAME=exec>exec</A>(LIST)<dt><A NAME=exec LIST>exec LIST</A><dd>
If there is more than one argument in LIST, or if LIST is an array with
more than one value,
calls execvp() with the arguments in LIST.
If there is only one scalar argument, the argument is checked for shell metacharacters.
If there are any, the entire argument is passed to "/bin/sh -c" for parsing.
If there are none, the argument is split into words and passed directly to
execvp(), which is more efficient.
Note: exec (and system) do not flush your output buffer, so you may need to
set <A HREF=pl-predef.html#$|>$|</A> to avoid lost output.
Examples:
<pre>
	exec '/bin/echo', 'Your arguments are: ', @ARGV;
	exec "sort $outfile | uniq";
</pre>
<p>
If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run by assigning that to a variable and
putting the name of the variable in front of the LIST without a comma.
(This always forces interpretation of the LIST as a multi-valued list, even
if there is only a single scalar in the list.)
Example:
<pre>
	$shell = '/bin/csh';
	exec $shell '-sh';		# pretend it's a login shell
</pre>
<p><dt><A NAME=exit>exit</A>(EXPR)<dt><A NAME=exit EXPR>exit EXPR</A><dd>
Evaluates EXPR and exits immediately with that value.
Example:
<pre>
	$ans = &lt;STDIN&gt;;
	exit 0 <A HREF=pl-compound.html#if>if</A> $ans <A HREF=pl-exp-op.html#=~>=~</A> /^[Xx]/;
</pre>
See also
<I>die</I>.
If EXPR is omitted, exits with 0 status.
<p><dt><A NAME=fork>fork</A><dd>Does a fork() call.
Returns the child pid to the parent process and 0 to the child process.
Note: unflushed buffers remain unflushed in both processes, which means
you may need to set <A HREF=pl-predef.html#$|>$|</A> to avoid duplicate output.
<p><dt><A NAME=getlogin>getlogin</A><dd>Returns the current login from /etc/utmp, if any.
If null, use getpwuid.

	$login = getlogin || (getpwuid(<A HREF=pl-predef.html#$&lt;>$&lt;</A>))[0] || "Somebody";

<p><dt><A NAME=getpgrp>getpgrp</A>(PID)<dt><A NAME=getpgrp PID>getpgrp PID</A><dd>
Returns the current process group for the specified PID, 0 for the current
process.
Will produce a fatal error if used on a machine that doesn't implement
getpgrp(2).
If EXPR is omitted, returns process group of current process.
<p><dt><A NAME=getppid>getppid</A><dd>Returns the process id of the parent process.
<p><dt><A NAME=getpriority>getpriority</A>(WHICH,WHO)<dd>Returns the current priority for a process, a process group, or a user.
(See getpriority(2).)
Will produce a fatal error if used on a machine that doesn't implement
getpriority(2).
<p><dt><A NAME=kill>kill</A>(LIST)<dt><A NAME=kill LIST>kill LIST</A><dd>
Sends a signal to a list of processes.
The first element of the list must be the signal to send.
Returns the number of processes successfully signaled.
<pre>
	$cnt = kill 1, $child1, $child2;
	kill 9, @goners;
</pre>
If the signal is negative, kills process groups instead of processes.
(On System V, a negative <I>process</I> number will also kill process groups,
but that's not portable.)
You may use a signal name in quotes.
<p><dt><A NAME=setpgrp>setpgrp</A>(PID,PGRP)<dd>Sets the current process group for the specified PID, 0 for the current
process.
Will produce a fatal error if used on a machine that doesn't implement
setpgrp(2).
<p><dt><A NAME=setpriority>setpriority</A>(WHICH,WHO,PRIORITY)<dd>Sets the current priority for a process, a process group, or a user.
(See setpriority(2).)
Will produce a fatal error if used on a machine that doesn't implement
setpriority(2).
<p><dt><A NAME=sleep>sleep</A>(EXPR)<dt>sleep EXPR
<dt><A NAME=sleep>sleep</A><dd>Causes the script to sleep for EXPR seconds, or forever if no EXPR.
May be interrupted by sending the process a SIGALRM.
Returns the number of seconds actually slept.
You probably cannot mix alarm() and sleep() calls, since sleep() is
often implemented using alarm().
<p><dt><A NAME=syscall>syscall</A>(LIST)<dt><A NAME=syscall LIST>syscall LIST</A><dd>
Calls the system call specified as the first element of the list, passing
the remaining elements as arguments to the system call.
If unimplemented, produces a fatal error.
The arguments are interpreted as follows: if a given argument is numeric,
the argument is passed as an int.
If not, the pointer to the string value is passed.
You are responsible to make sure a string is pre-extended long enough
to receive any result that might be written into a string.
If your integer arguments are not literals and have never been interpreted
in a numeric context, you may need to add 0 to them to force them to look
like numbers.
<pre>
	<A HREF=pl-exp-misc.html#require>require</A> 'syscall.ph';		# may need to run h2ph
	syscall(&amp;SYS_write, <A HREF=pl-exp-io.html#fileno>fileno</A>(STDOUT), "hi there\n", 9);
</pre>
<p><dt><A NAME=system>system</A>(LIST)<dt><A NAME=system LIST>system LIST</A><dd>
Does exactly the same thing as "exec LIST" except that a fork
is done first, and the parent process waits for the child process to complete.
Note that argument processing varies depending on the number of arguments.
The return value is the exit status of the program as returned by the wait()
call.
To get the actual exit value divide by 256.
See also
<I>exec</I>.
<p><dt><A NAME=time>time</A><dd>Returns the number of non-leap seconds since 00:00:00 UTC, January 1, 1970.
Suitable for feeding to <A HREF=pl-exp-conv.html#gmtime>gmtime</A>() and <A HREF=pl-exp-conv.html#localtime>localtime</A>().
<p><dt><A NAME=times>times</A><dd>Returns a four-element array giving the user and system times, in seconds, for this
process and the children of this process.
<p>
    ($user,$system,$cuser,$csystem) = times;
<p>
<p><dt><A NAME=umask>umask</A>(EXPR)<dt>umask EXPR
<dt><A NAME=umask>umask</A><dd>Sets the umask for the process and returns the old one.
If EXPR is omitted, merely returns current umask.
<p><dt><A NAME=wait>wait</A><dd>Waits for a child process to terminate and returns the pid of the deceased
process, or -1 if there are no child processes.
The status is returned in <A HREF=pl-predef.html#$?>$?</A>.
<p><dt><A NAME=waitpid>waitpid</A>(PID,FLAGS)<dd>Waits for a particular child process to terminate and returns the pid of the deceased
process, or -1 if there is no such child process.
The status is returned in <A HREF=pl-predef.html#$?>$?</A>.
If you say
<pre>
	<A HREF=pl-exp-misc.html#require>require</A> "sys/wait.h";
	...
	waitpid(-1,&amp;WNOHANG);
</pre>
then you can do a non-blocking wait for any process.  Non-blocking wait
is only available on machines supporting either the
<I>waitpid (2)</I>
or
<I>wait4 (2)</I>
system calls.
However, waiting for a particular pid with FLAGS of 0 is implemented
everywhere.  (Perl emulates the system call by remembering the status
values of processes that have exited but have not been harvested by the
Perl script yet.)
<p><dt><A NAME=warn>warn</A>(LIST)<dt><A NAME=warn LIST>warn LIST</A><dd>
Produces a message on STDERR just like "die", but doesn't exit.
</dl>
