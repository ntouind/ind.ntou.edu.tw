<title>PERL -- Miscellaneous Operations</title>
<H3>Miscellaneous Operations</H3>

<dl compact>
<p><dt><A NAME=caller>caller</A>(EXPR)<dt><A NAME=caller>caller</A><dd>
Returns the context of the current subroutine call:
<pre>
	($package,$filename,$line) = caller;
</pre>
With EXPR, returns some extra information that the debugger uses to print
a stack trace.  The value of EXPR indicates how many call frames to go
back before the current one.
<p><dt><A NAME=defined>defined</A>(EXPR)<dt><A NAME=defined EXPR>defined EXPR</A><dd>
Returns a boolean value saying whether the lvalue EXPR has a real value
or not.
Many operations return the undefined value under exceptional conditions,
such as end of file, uninitialized variable, system error and such.
This function allows you to distinguish between an undefined null string
and a defined null string with operations that might return a real null
string, in particular referencing elements of an array.
You may also check to see if arrays or subroutines exist.
Use on predefined variables is not guaranteed to produce intuitive results.
Examples:
<pre>
	<A HREF=pl-exp-io.html#print>print</A> <A HREF=pl-compound.html#if>if</A> defined $switch{'D'};
	<A HREF=pl-exp-io.html#print>print</A> "$val\n" <A HREF=pl-compound.html#while>while</A> defined($val = <A HREF=pl-exp-arr.html#pop>pop</A>(@ary));
	<A HREF=pl-exp-sys.html#die>die</A> "Can't readlink $sym: <A HREF=pl-predef.html#$!>$!</A>"
		unless defined($value = <A HREF=pl-exp-file.html#readlink>readlink</A> $sym);
	<A HREF=pl-exp-str.html#eval>eval</A> '@foo = ()' <A HREF=pl-compound.html#if>if</A> defined(@foo);
	<A HREF=pl-exp-sys.html#die>die</A> "No XYZ package defined" unless defined %_XYZ;
	sub foo { defined &amp;$bar ? &amp;$bar(@_) : <A HREF=pl-exp-sys.html#die>die</A> "No bar"; }
</pre>
See also undef.
<p><dt><A NAME=dump>dump</A> LABEL<dd>This causes an immediate core dump.
Primarily this is so that you can use the undump program to turn your
core dump into an executable binary after having initialized all your
variables at the beginning of the program.
When the new binary is executed it will begin by executing a "goto LABEL"
(with all the restrictions that goto suffers).
Think of it as a goto with an intervening core dump and reincarnation.
If LABEL is omitted, restarts the program from the top.
WARNING: any files opened at the time of the dump will NOT be open any more
when the program is reincarnated, with possible resulting confusion on the part
of perl.
See also -u.
<p>
Example:
<pre>
	#!/usr/bin/perl
	require 'getopt.pl';
	require 'stat.pl';
	%days = (
	    'Sun',1,
	    'Mon',2,
	    'Tue',3,
	    'Wed',4,
	    'Thu',5,
	    'Fri',6,
	    'Sat',7);

	dump QUICKSTART <A HREF=pl-compound.html#if>if</A> $ARGV[0] <A HREF=pl-exp-op.html#eq>eq</A> '-d';

    QUICKSTART:
	<A HREF=pl-exp-flow.html#do>do</A> Getopt('f');
</pre>
<p><dt><A NAME=local>local</A>(LIST)<dd>Declares the listed variables to be local to the enclosing block,
subroutine, <A HREF=pl-exp-str.html#eval>eval</A> or "<A HREF=pl-exp-flow.html#do>do</A>".
All the listed elements must be legal lvalues.
This operator works by saving the current values of those variables in LIST
on a hidden stack and restoring them upon exiting the block, subroutine or eval.
This means that called subroutines can also reference the local variable,
but not the global one.
The LIST may be assigned to if desired, which allows you to initialize
your local variables.
(If no initializer is given for a particular variable, it is created with
an undefined value.)
Commonly this is used to name the parameters to a subroutine.
Examples:
<pre>
	sub RANGEVAL {
		local($min, $max, $thunk) = @_;
		local($result) = '';
		local($i);

		# Presumably $thunk makes reference to $i

		<A HREF=pl-compound.html#for>for</A> ($i = $min; $i &lt; $max; $i++) {
			$result .= <A HREF=pl-exp-str.html#eval>eval</A> $thunk;
		}

		$result;
	}

	<A HREF=pl-compound.html#if>if</A> ($sw <A HREF=pl-exp-op.html#eq>eq</A> '-v') {
	    # init local array with global array
	    local(@ARGV) = @ARGV;
	    <A HREF=pl-exp-arr.html#unshift>unshift</A>(@ARGV,'echo');
	    <A HREF=pl-exp-sys.html#system>system</A> @ARGV;
	}
	# @ARGV restored

	# temporarily add to digits associative array
	<A HREF=pl-compound.html#if>if</A> ($base12) {
		# (NOTE: not claiming this is efficient!)
		local(%digits) = (%digits,'t',10,'e',11);
		<A HREF=pl-exp-flow.html#do>do</A> parse_num();
	}
</pre>
Note that local() is a run-time command, and so gets executed every time
through a loop, using up more stack storage each time until it's all
released at once when the loop is exited.
<p><dt><A NAME=require>require</A>(EXPR)<dt>require EXPR
<dt><A NAME=require>require</A><dd>Includes the library file specified by EXPR, or by <A HREF=pl-predef.html#$_>$_</A> if EXPR is not supplied.
Has semantics similar to the following subroutine:
<pre>
	sub require {
	    local($filename) = @_;
	    <A HREF=pl-exp-flow.html#return>return</A> 1 <A HREF=pl-compound.html#if>if</A> $INC{$filename};
	    local($realfilename,$result);
	    ITER: {
		<A HREF=pl-compound.html#foreach>foreach</A> $prefix (@INC) {
		    $realfilename = "$prefix/$filename";
		    <A HREF=pl-compound.html#if>if</A> (-f $realfilename) {
			$result = <A HREF=pl-exp-flow.html#do>do</A> $realfilename;
			<A HREF=pl-exp-flow.html#last>last</A> ITER;
		    }
		}
		<A HREF=pl-exp-sys.html#die>die</A> "Can't find $filename in \@INC";
	    }
	    <A HREF=pl-exp-sys.html#die>die</A> <A HREF=pl-predef.html#$@>$@</A> <A HREF=pl-compound.html#if>if</A> <A HREF=pl-predef.html#$@>$@</A>;
	    <A HREF=pl-exp-sys.html#die>die</A> "$filename did not return true value" unless $result;
	    $INC{$filename} = $realfilename;
	    $result;
	}
</pre>
Note that the file will not be included twice under the same specified name.
The file must return true as the last statement to indicate successful
execution of any initialization code, so it's customary to end
such a file with "1;" unless you're sure it'll return true otherwise.
<p><dt><A NAME=reset>reset</A>(EXPR)<dt>reset EXPR
<dt><A NAME=reset>reset</A><dd>Generally used in a
<I>continue</I>
block at the end of a loop to clear variables and reset ?? searches
so that they work again.
The expression is interpreted as a list of single characters (hyphens allowed
for ranges).
All variables and arrays beginning with one of those letters are reset to
their pristine state.
If the expression is omitted, one-match searches (?pattern?) are reset to
match again.
Only resets variables or searches in the current package.
Always returns 1.
Examples:
<pre>
    reset 'X';		# reset all X variables
    reset 'a-z';	# reset lower case variables
    reset;		# just reset ?? searches
</pre>
Note: resetting "A-Z" is not recommended since you'll wipe out your ARGV and ENV
arrays.
<p>
The use of reset on dbm associative arrays does not change the dbm file.
(It does, however, flush any entries cached by perl, which may be useful if
you are sharing the dbm file.
Then again, maybe not.)
<p><dt><A NAME=scalar>scalar</A>(EXPR)<dd>Forces EXPR to be interpreted in a scalar context and returns the value
of EXPR.
<p><dt><A NAME=undef>undef</A>(EXPR)<dt>undef EXPR
<dt><A NAME=undef>undef</A><dd>Undefines the value of EXPR, which must be an lvalue.
Use only on a scalar value, an entire array, or a subroutine name (using &amp;).
(Undef will probably not do what you expect on most predefined variables or
dbm array values.)
Always returns the undefined value.
You can omit the EXPR, in which case nothing is undefined, but you still
get an undefined value that you could, for instance, return from a subroutine.
Examples:
<pre>
	undef $foo;
	undef $bar{'blurfl'};
	undef @ary;
	undef %assoc;
	undef &amp;mysub;
	<A HREF=pl-exp-flow.html#return>return</A> (wantarray ? () : undef) <A HREF=pl-compound.html#if>if</A> $they_blew_it;
</pre>
<p><dt><A NAME=wantarray>wantarray</A><dd>Returns true if the context of the currently executing subroutine
is looking for an array value.
Returns false if the context is looking for a scalar.
<pre>
	<A HREF=pl-exp-flow.html#return>return</A> wantarray ? () : undef;
</pre>
</dl>
